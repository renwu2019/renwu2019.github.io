<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="Redis深度历险 | 学习记录, ##">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48">
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7">
    <meta name="description" content="Redis深度历险-核心原理与应用实践（钱文品）redis经典问题：数据缓存，使用get/set方法。Redis分布式锁及其内部实现机制，Redis是单线程结构，支持高并发。
一、基础应用篇
Redis（Remote Dictionary ">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Redis深度历险 | 学习记录 | 猷煜的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?ce84511d3df71640a9378a69f6293044";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">猷煜的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-comments"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">猷煜的博客</div>
        <div class="logo-desc">
            
            南昌大学 | 计算机技术 |
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-comments"></i>
                
                留言板
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/renwu2019/renwu2019.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/renwu2019/renwu2019.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/14.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        Redis深度历险 | 学习记录
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        <span class="chip bg-color">无标签</span>
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-04-21
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    猷煜
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    43k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    173 分
                </div>
                
                

                
                <div id="busuanzi_container_page_pv" class="info-break-policy">
                    <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                    <span id="busuanzi_value_page_pv"></span>
                </div>
                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Redis深度历险-核心原理与应用实践（钱文品）"><a href="#Redis深度历险-核心原理与应用实践（钱文品）" class="headerlink" title="Redis深度历险-核心原理与应用实践（钱文品）"></a>Redis深度历险-核心原理与应用实践（钱文品）</h1><p>redis经典问题：数据缓存，使用get/set方法。Redis分布式锁及其内部实现机制，Redis是单线程结构，支持高并发。</p>
<h2 id="一、基础应用篇"><a href="#一、基础应用篇" class="headerlink" title="一、基础应用篇"></a>一、基础应用篇</h2><ol>
<li><p><strong>Redis（Remote Dictionary Service, 远程字典服务）</strong></p>
<ul>
<li>面试引子：Redis能做什么？缓存，相对Memcache，Redis更加易于理解、使用和控制。分布式锁，一般是架构师封装好的。</li>
<li>Redis可以做什么？<ul>
<li>记录帖子的点赞数、评论数和点击数（hash）</li>
<li>记录用户的帖子ID列表（排序），便于快速显示用户的帖子列表（zset）</li>
<li>记录贴子的相关文章ID，根据内容推荐相关帖子（list）</li>
<li>等等</li>
</ul>
</li>
<li>Redis由意大利人Salvatore Sanfilippo（网名Antirez）开发。Redis默认端口6379是由手机键盘MERZ位置决定的。</li>
</ul>
</li>
<li><p><strong>Redis基础数据结构</strong> | 万丈高楼平地起</p>
<ul>
<li><p>Redis的安装</p>
<p>需使用Linux或者Mac环境，有三种安装方式：Docker；Github源码编译；直接安装apt-get install（Ubuntu）、yum install（Red Hat）或者brew install （Mac）。</p>
</li>
<li><p>5种基础数据结构：string(字符串) | list(列表) | hash(字典) | set(集合) | zset(有序集合)</p>
<ul>
<li><p><strong>string（字符串）</strong></p>
<p>内部表示就是一个字符数组。Redis所有数据结构都以唯一的key字符串作为名称，然后通过这个唯一的key值来获取响应的value数据。</p>
<p>字符串结构使用很广泛，一个常见用途是缓存用户信息，我们将用户信息结构体使用JSON序列化成字符串，然后将它塞进Redis进行缓存，取用户信息时经过一次反序列化。</p>
<p>Redis的字符串是动态字符串，是可以修改的。当前字符串分配的实际空间capacity一般要高于实际字符串长度len。当字符串长度小于1MB时，扩容是加倍现有空间。当字符串长度超过1MB，扩容一次只会多扩1MB。字符串最大长度为512MB。</p>
<p><em>【键值对】</em></p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> set name codehole # 增 key=name，value=codehole
OK
> get name # 查
"codehole"
> exists name
(integer) 1
> del name # 删
(integer) 1
> get name
(nil)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>【批量键值对】</em>，可以对字符串进行批量读写，节省网络耗时开销</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> set name1 codehole
OK
> set name2 holycoder
OK
> mget name1 name2 name3 # 返回一个列表
1) "codehole"
2) "holycoder"
3) (nil)
> mset name1 boy name2 girl name3 unknown # 改
> mget name1 name2 name3
1) "boy"
2) "girl"
3) "unknown"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>【过期和set命令扩展】</em>，对key设置过期时间，到时间会被自动删除，常用来控制缓存的失效时间。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> set name codehole
> get name
"codehole"
> expire name 5 # 5s后过期
... # 等候5s
> get name
(nil)
> setex name 5 codehole # 5s后过期，等价于set + expire
> setnx name codehole # 如果name不存在就执行set创建，否则创建不成功
(integer) 1
> get name
"codehole"
> setnx name holycoder # 由于name已经存在，所以set创建不成功
(integer) 0
> get name
"codehole" # 没有改变<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>【计数】</em>，如果value是一个整数，可以对它进行自增操作。自增范围在signed long最大最小值之间，超出范围会报错。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> set age 30
OK
> incr age
(integer) 31
> incrby age 5
(integer) 36
> incrby age -5
(integer) 31
> set codehole 9223372036854775807 # Long.Max
OK
> incr codehole
(error) ERR increment or decrement would overflow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>list（列表）</strong></p>
<p>Redis的列表相当于Java中的LinkedList，是链表而不是数组（底层是快速列表quicklist）。插删O(1)，查询O(n)。列表中每个元素都是用双向指针，支持前向和后向遍历。</p>
<p>常用作异步队列使用，将需要延后处理的任务结构体序列化成字符串，塞进Redis列表，另一个线程从这个列表中轮询数据进行处理。</p>
<p><em>【右边进左边出：队列</em>】，常用于消息排队和异步逻辑处理</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> rpush books python java golang # rpush从右边先进 python先进，在左
(integer) 3
> llen books
(integer) 3
> lpop books # 左边弹出
"python"
> lpop books 
"java"
> lpop books
"golang"
> lpop books
(nil)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>【右边进右边出：栈】</em>，业务场景不多</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> rpush books python java golang
(integer) 3
> rpop books # 右边弹出
"golang"
> rpop books
"java"
> rpop books
"python"
> rpop books
(nil)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>【慢操作】</em>，lindex相当于java链表的get(int index)方法，需要对链表遍历（0是第一个元素）。index可以是负数，index = -x表示倒数第x个元素。ltrim有两个参数start_index和end_index（闭区间），在这个区间的值ltrim都要保留，其余的删除，这可以用来实现一个定长的链表。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> rpush books python java golang
(integer) 3
> lindex books 1 # O(n)慎用
"java"
> lrange books 0 -1 # 获取所有元素
1) "pyhton"
2) "java"
3) "golang"
> ltrim books 1 -1 # 截取第二个到倒数第一个的区间链表
OK
> lrange books 0 -1
1) "java"
2) "golang"
> ltrim books 1 0 # 其实清空了整个列表，因为区间范围长度为负了
OK
> llen books
(integer) 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>【快速列表】</em>，Redis列表底层是一个快速链表（quicklist），而不是一个简单的linkedlist（容易造成空间冗余，加重内存碎片化）。</p>
<p>在列表元素较少情况，会使用一块连续的内存存储，这个结构是压缩列表（ziplist）（不满足快速插入和删除），当数据量较多时，才改成quicklist。Redis将链表和ziplist结合起来组成了quicklist，即将多个ziplist使用双向指针串起来使用，既满足快速插入删除性能，又不会出现太大的空间冗余。</p>
</li>
<li><p><strong>hash（字典）</strong></p>
<p>无序字典，内部存储了很多键值对，底层是数组+链表二维结构。注意：Redis字典的值只能是字符串（和java HashMap不同），另外他们rehash的方式不一样。java中rehash需要一次性全部rehash，Redis为了追求高性能，不能堵塞服务，采用了渐进式rehash策略。</p>
<p>渐进式rehash会在rehash同时保留新旧两个hash结构，查询时会同时查询两个hash结构，然后在后续的定时任务和hash操作指令中，循序渐进的将旧hash内容迁移到新hash结构中。当迁移完了，就会使用新的hash结构代替旧的。当hash移除了最后一个元素，该数据结构就会被自动删除，内存被回收。</p>
<p>hash结构也可以存储用户信息，字符串存储用户信息需要一次性序列化整个对象，而hash可以对用户结构中的每个字段单独存储，这样可以取部分用户信息，节省网络流量。hash缺点：其结构存储消耗高于单个字符串，使用hash还是字符串视情况而定。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> hset books java "think in java" # 命令行的字符串如果包含空格需要引号。
(integer) 1
> hset books golang "concurrency in go"
(integer) 1
> hset books python "python cookbook"
(integer) 1
> hgetall books # 获取所有键值对 entries()，key 和 value 间隔出现
1) "java"
2) "think in java"
3) "golang"
4) "concurrency in go"
5) "python"
6) "python cookbook"
> hlen books # 字典长度
(integer) 3
> hget books java # 根据键取值
"think in java"
> hset books golang "learning go programming" # 更新操作，返回0
(integer) 0
> hget books golang
"learning go programming"
> hmset books java "effective java" python "learning python" golang "modern golang programming" # 批量set
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同字符串一样，hash的单个字key也可以进行计数，对应指令hincrby，和incr使用方法基本一样</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> hset user-w age 29 # 29
(integer) 1
> hincrby user-w age 1 # 加1
(integer) 30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>set（集合）</strong></p>
<p>内部键值对是无序的、唯一的。内部实现相当于一个特殊的字典，字典所有的value都是一个值NULL。当集合中最后一个元素被移除后，数据结构被自动删除，内存被回收。可以用来存储某活动中中奖的用户ID，因为有去重功能，可以保证同一用户不会中奖两次。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> sadd books python
(integer) 1
> sadd books python # 重复
(integer) 0
> sadd books java golang # 批量添加
(integer) 2
> smembers books # 顺序和插入并不一致，因为set是无序的
1) "java"
2) "python"
3) "golang"
> sismember books java # 查询某个value是否存在
(integer) 1
> sismember books rust
(integer) 0
> scard books # 获取长度
(integer) 3
> spop books # 弹出一个
"java"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>zset（有序列表）</strong></p>
<p>类似于Java的SortedSet和HashMap的结合体，一方面它是set保证了内部value的唯一性，另一方面它可以给每个value赋予一个score，代表这个value的排序权重。内部实现是跳跃列表。zset最后一个value被移除后，数据结构会被自动删除，内存被回收。</p>
<p>zset可以用来存储粉丝列表，value值是粉丝的用户ID，score是关注时间。我们可以对粉丝列表按关注时间排序。还可以存储学生成绩，value是学生ID，score是他的成绩，对成绩排序从而得到名次。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> zadd books 9.0 "think in java"
(integer) 1
> zadd books 8.9 "java concurrency"
(integer) 1
> zadd books 8.6 "java cookbook"
(integer) 1
> zrange books 0 -1 # 按score排序列出，参数区间为排名范围 升序
1) "java cook book"
2) "java concurrency"
3) "think in java"
> zrevrange books 0 -1 # 按score逆序列出 降序
1) "think in java"
2) "java concurrency"
3) "java cook book"
> zcard books # 获取长度
(integer) 3
> zscore books "java concurrency" # 获取指定value的score
"8.9000000000000004" # 内部score使用double类型进行存储，所以存在小数点精度问题
> zrank books "java concurrency" # 排名
(integer) 1
> zrangebyscore books 0 8.91 # 根据分值区间遍历zset
1) "java cookbook"
2) "java concurrency"
> zrangebyscore books -inf 8.91 withscores # 根据分值区间(-无穷, 8.91]遍历zset，同时返回分值
1) "java cookbook"
2) "8.5999999999999996"
3) "java concurrency"
4) "8.9000000000000004"
> zrem books "java concurrency" # 删除value
(integer) 1
> zrange books 0 -1
1) "java cookbook"
2) "think in java"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>【跳跃列表】</em>，zset内部的排序是通过跳跃列表数据结构实现的。</p>
<p>由于zset要支持随机的插入和删除，不宜使用数组来表示。它实际上一个链表，但链表之间会有多个层级的跳跃的指针。比如有h0-&gt;0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9这10个节点，第一层，每个节点指向下一个节点；第二层，h1-&gt;1，1-&gt;3，3-&gt;5等等；第三次，h2-&gt;3，3-&gt;7等等。这样有的节点会处于多个层级。定位插入点时，先在顶层定位，然后一直下潜到下一级定位，直至最底层合适的位置。那新插入的节点如何才能处于多个层级呢？跳跃列表采用了一个随机策略来决定新元素可以处于第几层。首先位于L0层概率为100%，L1为50%，L2为25%，以此类推，一直随机到最顶层L31层。</p>
</li>
</ul>
</li>
<li><p>容器型数据结构的通用规则</p>
<p>除了string其他四种都是容器性数据结构。它们共享下面两条规则：</p>
<ul>
<li>create if not exists：如果容器不存在，就会创建一个。比如rpush操作刚开始没有列表，那么Redis就会创建一个，在rpush进去新元素。</li>
<li>drop if no elements：如果容器里的元素没有了，那么立即删除容器，释放内存。</li>
</ul>
</li>
<li><p>过期时间</p>
<p>Redis所有的数据结构都可以设置过期时间，过期是以对象为单位的，比如一个hash结构过期是整个hash过期，而不是某个子key的过期。如果一个字符串已经设置了过期，然后调用set方法修改了它，它的过期时间会消失</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> set codehole yoyo
OK
> expire codehole 600
(integer) 1
> ttl codehole
(integer) 597
> set codehole yoyo # 也就是说会覆盖（更新），而不是没有更改，不像setnx
OK
> ttl codehole
(integer) -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p><strong>分布式锁</strong> | 千帆竞发</p>
<p>分布式应用进行逻辑处理时经常会遇到并发问题。如client1 read -&gt; client2 read -&gt; client1 write -&gt; client2 write就会出现数据错误。因为读写这两个操作不是原子操作（指不会被线程调度机制打断的操作）。</p>
<ul>
<li><p>分布式锁的奥义</p>
<p>分布式锁的本质是抢占资源，当别的进程需要资源时，发现已经被占，则放弃或等待。</p>
<p>setnx(set if not exist)指令，只允许一个客户端占用，先来先占，用完再调用del指令释放。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> setnx lock:codehole true
OK
... do something critical ... # 如果有异常，del指令不会执行，则会陷入死锁
> del lock:codehole
(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>拿到锁后，给锁加上过期时间</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> setnx lock:codehole true
OK # 如果再setnx和expire之间服务器进程突然挂掉，就会导致expire得不到执行，也会造成死锁
> expire lock:codehole 5 # 5s过期时间
... do something critical ... 
> del lock:codehole
(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述问题根源在于setnx和expire是两个指令而不是原子指令。</p>
<p>Redis2.8引入set指令扩展参数，在这之前需要使用第三方分布式锁library来解决。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> set lock:codehole true ex 5 nx
OK
... do something critical
> del lock:codehole<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>超时问题</p>
<p>Redis的分布式锁不能解决超时问题。如果在加锁和释放锁之间的逻辑执行得太长，以致于超出了锁的超时限制，就会出现问题。因为第一个线程持有的锁过期了，临界区的逻辑还没有执行完，而同时第二个线程重新持有了这把锁，导致临界区代码不能很好串行执行。</p>
<p>为了避免这个问题，Redis分布式锁不要用于较长时间的任务。如果偶尔出现问题，造成数据小错乱可能需要人工介入解决。</p>
<p>有一个相对安全的方案：将set指令的value参数设置为一个随机数，释放锁时先匹配随机数是否一致，然后再删除key。（由于匹配value和删除key不是一个原子操作，需要Lua脚本处理，它可以保证连续多个指令的原子性执行。）</p>
</li>
<li><p>可重入性</p>
<p>可重入性指线程在持有锁的情况下再次请求加锁，如果一个锁支持同一个线程的多次加锁，那么这个锁就是可重入锁。如Java中的ReentrantLock就是可重入锁。Redis分布式锁如果要支持可重入，需要对客户端的set方法进行包装，使用线程的ThreadLocal变量存储当期持有锁的计数。</p>
<p>【注】：作者不推荐使用可重入锁，它加重了客户端的复杂性，在编写业务方法时注意在逻辑结构上进行调整完全可以不使用可重入锁。</p>
<p>可重入锁作用：避免死锁。比如这里dosomthing耗时，我们可以再dosomething里给一些操作加锁，使得该线程持有锁的引用加1。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 可重入锁java实现
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisWithReentrantLock</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> ThreadLocal<span class="token operator">&lt;</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">>></span> lockers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> Jedis jedis<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Jedis Redis的java版本的客户端实现</span>
    <span class="token keyword">public</span> <span class="token function">RedisWithReentrantLock</span><span class="token punctuation">(</span>Jedis jedis<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>jedis <span class="token operator">=</span> jedis<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">_lock</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"nx"</span><span class="token punctuation">,</span> <span class="token string">"ex"</span><span class="token punctuation">,</span> 5L<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">_unlock</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        jedis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> <span class="token function">currentLockers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> refs <span class="token operator">=</span> lockers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>refs <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> refs<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        lockers<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> lockers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">lock</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> refs <span class="token operator">=</span> <span class="token function">currentLockers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Integer refCnt <span class="token operator">=</span> refs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>refCnt <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            refs<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> refCnt <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">boolean</span> ok <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_lock</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ok<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        refs<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">unlock</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> refs <span class="token operator">=</span> <span class="token function">currentLockers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Integer refCnt <span class="token operator">=</span> refs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>refCnt <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        refCnt<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>refCnt <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            refs<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> refCnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            refs<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_unlock</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Jedis jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        RedisWithReentrantLock redis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisWithReentrantLock</span><span class="token punctuation">(</span>jedis<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token string">"codehole"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token string">"codehole"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token string">"codehole"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token string">"codehole"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * ThreadLocal讲解
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">// ThreadLocal 有一个静态内部类ThreadLocalMap</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// ThreadLocal的set方法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 获取当前线程</span>
        Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 获取当前线程的ThreadLocalMap成员变量</span>
        ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>
            <span class="token comment" spellcheck="true">// 当前线程成员变量map保存ThreadLocal引用并关联到泛型类型实例。</span>
            map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 功能和set一样，只不过new了一个ThreadLocalMap实例并保存相关信息传给当前线程的成员变量threadLocals。</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// ThreadLocal的get方法 返回set方法里关联的value的值</span>
    <span class="token keyword">public</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ThreadLocalMap<span class="token punctuation">.</span>Entry e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
                T result <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                <span class="token keyword">return</span> result<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Thread 有一个 ThreadLocal.ThreadLocalMap threadLocals成员变量</span>
    ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap threadLocals <span class="token operator">=</span> null<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/**
 * 测试
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestThreadLocal</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// SimpleDateFormat is not thread-safe, so give one to each thread</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ThreadLocal<span class="token operator">&lt;</span>SimpleDateFormat<span class="token operator">></span> formatter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>SimpleDateFormat<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 重写了该方法，当ThreadLocal实例即formatter调用get方法时，无需set方法，即可提供SimpleDateFormat实例。</span>
        <span class="token comment" spellcheck="true">// 也就是说不同的线程调用了formatter的parse或format方法，它的SimpleDateFormat实例是不同的。</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> SimpleDateFormat <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyyMMdd HHmm"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> Date <span class="token function">parse</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> formatter<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ParseException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> String <span class="token function">format</span><span class="token punctuation">(</span>Date date<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> formatter<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        TestThreadLocal testThreadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        SimpleDateFormat sf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span> <span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token annotation punctuation">@Override</span>
                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    String format <span class="token operator">=</span> testThreadLocal<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    Date date <span class="token operator">=</span> testThreadLocal<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>format<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    String format1 <span class="token operator">=</span> testThreadLocal<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"  "</span> <span class="token operator">+</span> format<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>format1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/*
ThreadLocal和Synchronized都是为了解决多线程中相同变量的访问冲突问题，不同的点是
Synchronized是通过线程等待，牺牲时间来解决访问冲突
ThreadLocal是通过每个线程单独一份存储空间，牺牲空间来解决冲突，并且相比于Synchronized，ThreadLocal具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问到想要的值。
正因为ThreadLocal的线程隔离特性，使他的应用场景相对来说更为特殊一些。在android中Looper、ActivityThread以及AMS中都用到了ThreadLocal。当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用ThreadLocal。
*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ol>
<ol start="4">
<li><p><strong>延时队列</strong> | 缓兵之计</p>
<p>使用Redis可以解决只有一组消费者的消息队列，但它不是专业的消息队列，没有ack保证，如果对消息的可靠性有极高要求，那么它就不适用。</p>
<ul>
<li><p>异步消息队列</p>
<p>常用list作为异步消息队列。它支持多个生产者和多个消费者并发进出消息。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">127.0.0.1:6379> rpush notify-queue apple banana pear # rpush 和 lpop结合
(integer) 3
127.0.0.1:6379> llen notify-queue
(integer) 3
127.0.0.1:6379> lpop notify-queue
"apple"
127.0.0.1:6379> lpop notify-queue
"banana"
127.0.0.1:6379> lpop notify-queue
"pear"
127.0.0.1:6379> llen notify-queue
(integer) 0
127.0.0.1:6379> lpop notify-queue
(nil)
# 也可使用lpush 和 rpop结合<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>队列空了怎么办</p>
<p>Redis客户端一般循环的对队列pop操作来获取消息，然后进行处理，处理完了再接着获取消息，再进行处理。当队列空了，客户端就会陷入pop的死循环，即空轮询。空轮询会拉高客户端cpu消耗，Redis的QPS（每秒查询率，Query Per Second）也会被拉高。通常我们使用sleep来解决这个问题。如java客户端使用Thread.sleep(1000)。</p>
</li>
<li><p>阻塞读</p>
<p>客户端sleep会带来延迟（也就是说sleep期间，即使消息到达了，我也不能立即处理），可以使用阻塞读，即blpop和brpop，前缀b代表blocking。阻塞读在队列没有数据的时候会进入休眠状态，一旦数据到来，则立即醒过来。消息的延迟几乎为零。</p>
</li>
<li><p>空闲连接自动断开</p>
<p>当然，上述阻塞读可能还会出现问题，如果线程一直阻塞在那里，Redis的客户端连接就成了空置连接，闲置过久，服务器一般会主动断开，这个时候blpop/brpop就会抛出异常，所以客户端需要捕获异常，并尝试重试。</p>
</li>
<li><p>锁冲突处理</p>
<p>客户端处理请求加锁没加成功的处理办法：</p>
<ul>
<li><p>直接抛出异常，通知用户稍后处理。</p>
<p>适合由用户直接发出的请求，当请求失败时，让用户选择是否重试，起到人工延时的效果。</p>
</li>
<li><p>sleep</p>
<p>不太合适，因为它会阻塞当前的消息处理线程，导致队列的后续消息处理出现延迟。更严重的会导致线程彻底堵死。</p>
</li>
<li><p>延时队列</p>
<p>比较适合异步消息处理，将当前冲突的请求扔到另一个队列延后处理。</p>
</li>
</ul>
</li>
<li><p>延时队列的实现</p>
<p>Redis的zset可实现。将消息序列化成一个字符串作为zset的value，这个消息的到期时间作为score，然后用多个线程轮询zset获取到期的任务进行处理。多线程是为了保障可用性，一个线程挂了还有其他线程可以继续处理。因而也需要考虑并发争抢任务的问题。</p>
<p>Redis的zrem方法是多线程多进程争抢任务的关键。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * java延时队列实现
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisDelayingQueue</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TaskItem</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> String id<span class="token punctuation">;</span>
        <span class="token keyword">public</span> T msg<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 序列化对象中存在generic类型</span>
    <span class="token keyword">private</span> Type TaskType <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TypeReference</span><span class="token operator">&lt;</span>TaskItem<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> Jedis jedis<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String queueKey<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">RedisDelayingQueue</span><span class="token punctuation">(</span>Jedis Jedis<span class="token punctuation">,</span> String queueKey<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>jedis <span class="token operator">=</span> jedis<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>queueKey <span class="token operator">=</span> queueKey<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 入队</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delay</span><span class="token punctuation">(</span>T msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        TaskItem<span class="token operator">&lt;</span>T<span class="token operator">></span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TaskItem</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        task<span class="token punctuation">.</span>id <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 分配唯一的uuid</span>
        task<span class="token punctuation">.</span>msg <span class="token operator">=</span> msg<span class="token punctuation">;</span>
        String s <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 序列化</span>
        jedis<span class="token punctuation">.</span><span class="token function">zadd</span><span class="token punctuation">(</span>queueKey<span class="token punctuation">,</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMills</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">5000</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 加入延时队列，5s后再试</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 轮询出队</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 线程没打断就一直继续</span>
            <span class="token comment" spellcheck="true">// 只取一条消息</span>
            Set<span class="token operator">&lt;</span>String<span class="token operator">></span> values <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">zrangeByScore</span><span class="token punctuation">(</span>queueKey<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMills</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>values<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 未取到消息，0.5s后继续取</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            String s <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">zrem</span><span class="token punctuation">(</span>queueKey<span class="token punctuation">,</span> s<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 抢到了任务</span>
                TaskItem<span class="token operator">&lt;</span>T<span class="token operator">></span> task <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> TaskType<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleMsg</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 处理消息</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMsg</span><span class="token punctuation">(</span>T msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span> <span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        RedisDelayingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisDelayingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"q-demo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 生产者进程 产生任务 入队</span>
        Thread producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    queue<span class="token punctuation">.</span><span class="token function">delay</span><span class="token punctuation">(</span><span class="token string">"codehole"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 消费者进程 消费任务 出队</span>
        Thread consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                queue<span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 生产者进程和消费者进程同时开启</span>
        consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法.避免主线程结束子线程还在继续。</span>
            producer<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 需要等待producer线程结束才继续往下执行</span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">6000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 6s之后结束loop</span>
            consumer<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            consumer<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 需要等待consumer线程结束才继续往下执行</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>进一步优化</p>
<p>zrem是决定线程是否抢到任务的，其他未抢到的线程或进程白取了一次任务，这是浪费。可以使用lua脚本来优化，将zrangebyscore和zrem一同挪到服务器端进行原子优化，这样多个进程之间争抢任务就会出现浪费了。</p>
</li>
</ul>
</li>
<li><p><strong>位图</strong> | 节衣缩食</p>
<p>场景需求：存取大量bool型数据，如用户一年的签到记录，签了是1，没签是0。java规范中没有明确指定boolean占用几个字节，但jvm一般占4个字节，和int类型一样。这需要根据jvm实现来看。如果是4字节，那么一年单个用户的数据占365 <em> 4个字节空间。如果使用位图，则只需46个字节即可（45 </em> 8 &lt; 365 &lt; 46 * 8）即可。这大大节省了空间。</p>
<p>位图的物理结构是byte数组（和存储字符串一样）。</p>
<ul>
<li><p>基本用法</p>
<p>Redis的位数组是自动扩展的，如果设置了某个偏移位置超出了现有的内容范围，就会自动将位数组进行零扩充（长度增加，内容为0）。</p>
<p><em>【零存整取】</em>，一位一位的存，整体获取。存储字符串”he”，只需对1的位置设置。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql"># 'h' ascii码为 01101000，'e' ascii码为 01100101，因此位图为0110100001100101，位置从0-15
> setbit s 1 1 # s有点像变量，应该是key
(integer) 0
> setbit s 2 1
(integer) 0
> setbit s 4 1
(integer) 0
> setbit s 9 1
(integer) 0
> setbit s 10 1
(integer) 0
> setbit s 13 1
(integer) 0
> setbit s 15 1
(integer) 0
> get s # 返回字符串"he"
"he"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>【零存零取】</em>，使用单个位操作设置位值和获取位值</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> setbit w 1 1
(integer) 0
> setbit w 2 1
(integer) 0
> setbit w 4 1
(integer) 0
> getbit w 1 # 获取某个具体位置的值 0/1，这里是第1个位置（从0开始）
(integer) 1
> getbit w 2
(integer) 1
> getbit w 4
(integer) 1
> getbit w 5
(integer) 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>【整存零取】</em>，使用字符串批量设置位值，使用单个位操作获取具体位值。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> set w h # 整存
(integer) 0
> getbit w 1
(integer) 1
> getbit w 2
(integer) 1
> getbit w 4
(integer) 1
> getbit w 5
(integer) 0
> setbit x 0 1 # 如果对应位的字节是不可打印字符，redis-cli会显示该字符十六进制形式。
> setbit x 1 1 # 0b11000000 = 0xc0
> get x
"\xc0"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>统计和查找</p>
<p>bitcount：统计指定范围内1的个数；bitpos：查找指定范围内出现的第一个0或1。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> set w hello
OK
> bitcount w # 统计hello字节数组内1的个数 （需求：一年内签到了多少次）
(integer) 21
> bitcount w 0 0 # 统计第一个字符中1的个数 （需求：一段时间内签到了多少次）注意以字节为一段。
(integer) 3
> bitcount w 0 1 # 统计前两个字符中1的个数 [0,1]
(integer) 7
# bitpos key bit [start] [end] 返回字符串里面第一个被设置为1或者0的bit位
> bitpos w 0 # 第一个0的位置
(integer) 0
> bitpos w 1 # 第一个1的位置 （需求：从哪一天开始签到）
(integer) 1
> bitpos w 1 1 1 # 第二个字符，第一个1位（从第2个字节到第2个字节）
(integer) 9
> bitpos w 1 2 2 # 第三个字符，第一个1位
(integer) 17<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>魔术指令bitfield</p>
<p>setbit、getbit都是操作单个位的，如果要一次操作多个位需要使用管道，但在Redis3.2后可以使用bitfield。</p>
<p>bitfield有三个子指令，set/get/incrby，最多处理64个连续的位，如果超过64位，需要多个子指令。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql"># "he" 01101000 01100101
> set w hello
OK
> bitfield w get u4 0 # 从第1个位开始取4个位，结果是无符号数(u)
(integer) 6 # 0110
> bitfield w get u3 2 # 从第3个位开始取3个位，结果是无符号数
(integer) 5 # 101
> bitfield w get i4 0 # 从第1个位开始取4个位，结果是有符号数(i)
(integer) 6 # 0110
> bitfield w get i3 2 # 从第3个位开始取3个位，结果是有符号数
(integer) -3 # 101 这个是负数，补码，实际值取反加1，即011 = 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意：Redis协议中integer是有符号数，最大64位，不能传递64位无符号值。有符号数最多获取64位（i64），无符号数最多获取63位（u63）</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> bitfield w get u4 0 get u3 2 get i4 0 get i3 2 # 一次多个指令
1) (integer) 6
2) (integer) 5
3) (integer) 6
4) (integer) -3
> bitfield w set u8 8 97 # 将第二个字符（第9位开始，到后面8个位）e改成a（ASCII 97）
1) (integer) 101
> get w
"hallo"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>incrby，对指定范围的位进行自增操作。溢出问题：正数可能上溢出，负数可能下溢出。解决方法：折返。如8位无符号数（0-255）255，加1后变为0；8位有符号（-128-127）127，加1变为-128。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> set w hello
> bitfield w incrby u4 2 1 # 从第3位开始，对接下来的4位无符号数+1
1) (integer) 11
> bitfield w incrby u4 2 1
1) (integer) 12
> bitfield w incrby u4 2 1
1) (integer) 13
> bitfield w incrby u4 2 1
1) (integer) 14
> bitfield w incrby u4 2 1
1) (integer) 15
> bitfield w incrby u4 2 1 # 溢出折返
1) (integer) 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>bitfield指令提供了溢出策略指令overflow，默认折返wrap，还可以选择失败(fail)：报错不执行。以及饱和截断(sat)：超过了范围就停留在最大或最小值。overflow只会影响接下来第一条指令，这条指令执行完后溢出策略会变成默认值折返(wrap)。</p>
<p><em>【饱和截断（sat）】</em></p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> set w hello
> bitfield w overflow sat incrby u4 2 1
1) (integer) 11
> bitfield w overflow sat incrby u4 2 1
1) (integer) 12
> bitfield w overflow sat incrby u4 2 1
1) (integer) 13
> bitfield w overflow sat incrby u4 2 1
1) (integer) 14
> bitfield w overflow sat incrby u4 2 1
1) (integer) 15
> bitfield w overflow sat incrby u4 2 1
1) (integer) 15 # 保持最大值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>【失败不执行（fail）】</em></p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> set w hello
> bitfield w overflow fial incrby u4 2 1
1) (integer) 11
> bitfield w overflow fial incrby u4 2 1
1) (integer) 12
> bitfield w overflow fial incrby u4 2 1
1) (integer) 13
> bitfield w overflow fial incrby u4 2 1
1) (integer) 14
> bitfield w overflow fial incrby u4 2 1
1) (integer) 15
> bitfield w overflow fial incrby u4 2 1 # 不执行
(nil)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p><strong>HyperLogLog</strong> | 四两拨千斤</p>
<p>场景：PV和UV数据。</p>
<p>解决：PV数据，给每个网页配一个独立的Redis计数器，给计数器的key后缀加一个当天的日期。这样，来一个请求，就执行incrby指令一次。UV数据，使用set存储用户id，来一个请求就把用户id加入set，set大小就是UV数据。但是当用户量特别大，如几千万，这种方式特别耗费内存，可以使用HyperLogLog来解决（统计是不精确的，但实际需求是可以接受的）。</p>
<ul>
<li><p>使用方法</p>
<p>pfadd：增加计数；pfcount：获取计数。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">127.0.0.1:6379> pfadd codehole user1
(integer) 1
127.0.0.1:6379> pfcount codehole
(integer) 1
127.0.0.1:6379> pfadd codehole user2
(integer) 1
127.0.0.1:6379> pfcount codehole
(integer) 2
127.0.0.1:6379> pfadd codehole user3 user4 user5 user6 user7 user8
(integer) 1
127.0.0.1:6379> pfcount codehole
(integer) 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>pfadd中的pf</p>
<p>HyperLogLog数据结构发明人Philippe Flajolet。pf是他名字首字母缩写。</p>
</li>
<li><p>pfmerge适合的场合</p>
<p>pfmerge：将多个pf计数值累加在一起形成一个新的pf值。场景：网站中两个内容差不多的页面。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">127.0.0.1:6379> pfadd key1 user1 user2 user3
(integer) 1
127.0.0.1:6379> pfcount key1 # key1有三个用户
(integer) 3
127.0.0.1:6379> pfadd key2 user1 user4 user5
(integer) 1
127.0.0.1:6379> pfcount key2 # key2有三个用户
(integer) 3
127.0.0.1:6379> pfmerge key3 key1 key2 # 合并key1和key2的用户到key3，同时去重user1
OK
127.0.0.1:6379> pfcount key3
(integer) 5
127.0.0.1:6379> pfmerge key1 key2 # 合并key2的用户到key1
OK
127.0.0.1:6379> pfcount key1
(integer) 5
127.0.0.1:6379> 
# pfmerge destkey sourcekey1 sourcekey2...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>注意事项</p>
<p>HyperLogLog在计数比较时，其存储空间采用稀疏矩阵存储，当计数变大，稀疏矩阵占用空间超过阈值时，才会一次性转变为稠密矩阵，才会占用12KB的空间。</p>
</li>
<li><p>HyperLogLog实现原理</p>
<p><a href="https://www.cnblogs.com/linguanh/p/10460421.html" target="_blank" rel="noopener">https://www.cnblogs.com/linguanh/p/10460421.html</a></p>
<p>n = 2^(k_max) 。通过局部信息预估整体数据流特性</p>
</li>
<li><p>pf的内存占用为什么是12KB</p>
<p>HyperLogLog实现用的是16384个桶，也就是2^14，每个桶的maxbits需要6个bit来存储，最大可表示maxbits=63，于是总共占用内存就是2^14 <em> 6 / 8 = 12KB = 2 </em> 6 <em> 2 ^ 10 </em> 8bit</p>
</li>
</ul>
</li>
<li><p><strong>布隆过滤器</strong> | 层峦叠嶂</p>
<p>场景：推荐系统给用户推荐的内容保证不重复。</p>
<p>普通解决：记录用户看过的所有记录，再推荐时，判断内容是否在历史记录里。时间和空间复杂度都很高。</p>
<p>Bloom Filter专门解决这类问题，空间上能节省90%以上，但有一定的误判概率。</p>
<p>特性：如果布隆过滤器认为某个值不存在，那就一定不存在（可以保证永远推荐新的内容）；如果它认为某个值存在，一般实际上是存在，但有可能是误判，实际上是不存在。</p>
<ul>
<li><p>Redis中的布隆过滤器</p>
<p>Redis4.0提供插件后才可用。它作为插件加载到Redis Server中，给Redis提供了强大的布隆过滤去重功能。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> docker pull redislabs/rebloom
> docker run -p6379:6379 redislabs/rebloom # 本地redis需要关闭
> redis-cli # 另起命令行窗口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>基本用法</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">127.0.0.1:6379> bf.add codehole user1
(integer) 1
127.0.0.1:6379> bf.add codehole user2
(integer) 1
127.0.0.1:6379> bf.add codehole user3
(integer) 1
127.0.0.1:6379> bf.exists codehole user1
(integer) 1
127.0.0.1:6379> bf.exists codehole user2
(integer) 1
127.0.0.1:6379> bf.exists codehole user4
(integer) 0
127.0.0.1:6379> bf.add codehole user4 user5 user6
(error) ERR wrong number of arguments for 'bf.add' command
127.0.0.1:6379> bf.madd codehole user4 user5 user6
1) (integer) 1
2) (integer) 1
3) (integer) 1
127.0.0.1:6379> bf.mexists codehole user4 user5 user7 user6
1) (integer) 1
2) (integer) 1
3) (integer) 0
4) (integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># coding: utf-8</span>
<span class="token keyword">import</span> redis

client <span class="token operator">=</span> redis<span class="token punctuation">.</span>StrictRedis<span class="token punctuation">(</span><span class="token punctuation">)</span>
client<span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token string">"codehole"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># for i in range(100000):</span>
<span class="token comment" spellcheck="true">#     client.execute_command("bf.add", "codehole", "user%d" % i)</span>
<span class="token comment" spellcheck="true">#     # 测试布隆过滤器是否误判已经存在的user为不存在</span>
<span class="token comment" spellcheck="true">#     ret = client.execute_command("bf.exists", "codehole", "user%d" % i)</span>
<span class="token comment" spellcheck="true">#     if ret == 0:  # 不存在就打印出来，实验证明没有打印出来，布隆过滤器认为存在，实际上也是存在</span>
<span class="token comment" spellcheck="true">#         print("第" + str(i) + "个不存在，实际上存在。误判了！")</span>
<span class="token comment" spellcheck="true">#         break</span>
false <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    client<span class="token punctuation">.</span>execute_command<span class="token punctuation">(</span><span class="token string">"bf.add"</span><span class="token punctuation">,</span> <span class="token string">"codehole"</span><span class="token punctuation">,</span> <span class="token string">"user%d"</span> <span class="token operator">%</span> i<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># 测试布隆过滤器是否误判不存在的user为存在</span>
    ret <span class="token operator">=</span> client<span class="token punctuation">.</span>execute_command<span class="token punctuation">(</span><span class="token string">"bf.exists"</span><span class="token punctuation">,</span> <span class="token string">"codehole"</span><span class="token punctuation">,</span> <span class="token string">"user%d"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> ret <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 存在就打印出来，布隆过滤器认为存在，实际上不存在。实验证明不存在的会误判成存在</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"第"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"个存在，实际上不存在。误判了！"</span><span class="token punctuation">)</span>
        false <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token comment" spellcheck="true"># break</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>false<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 误判了888个，误判率不到1%</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Redis提供了bf.reserve指令显示创建布隆过滤器。如果对应key已经存在，bf.reverse会报错。它有三个参数：key、error_rate（错误率，默认0.01）和initial_size（预计放入的元素数量，默认100）。</p>
<p>错误率越低，需要空间越大；当实际数量超过inital_size，会导致误判率升高。</p>
</li>
<li><p>注意事项</p>
<p>inital_size设置应尽量合适，使用前合理估计元素数量，加上一定的冗余空间，避免出现实际高出估计量很多的情况。对于精确率要求不高的场景，error_rate设置稍大一点也不要紧，节省空间。</p>
</li>
<li><p>布隆过滤器的原理</p>
<p>布隆过滤器对应到Redis的数据结构就是一个大型的位数组和几个不一样的无偏hash函数（能够把元素的hash值算的比较均匀，让元素被hash映射到位数组中的位置比较随即）。</p>
<p>向布隆过滤器添加key时（即上面的user1, user2…），会使用多个hash函数对key进行hash，对位数组长度取模，每个hash函数都会算的一个不同的位置，再把对应位置置为1。</p>
<p>判断key是否存在时，进行同样hash操作，判断对应位置的值，如果有一个是0，那么key一定不存在。如果位置都是1，并不能说明key一定存在，只是极有可能存在（由于hash冲突）。如果数组比较稀疏，判读正确概率就会很大，反之，概率会降低。</p>
</li>
<li><p>空间占用估计</p>
<p>f = 0.6185 ^ (l / n) ， l表示位数组的长度，n是预计元素数量，f是错误率</p>
<p>k = 0.7 * (l / n)，k表示hash函数的最佳数量</p>
<p>位数组相对越长（l / n），错误率f就越低；hash函数需要的最佳数量也越多，影响计算效率。</p>
<p>当一个元素平均需要1个字节（8bit）的指纹空间（l / n = 8）时，错误率大约为2%。</p>
<p>错误率为0.1%时，l / n = 14.377bit，约为15bit。而用set去重的话，一个元素占用大小就是它本身的大小，而这里只需要15bit的大小，可以说很赚了。</p>
</li>
<li><p>实际元素超出时，误判率会怎样变化</p>
<p>f = (1 - 0.5 ^ t) ^ k，k是函数的最佳数量，t是实际元素和预计元素的倍数。</p>
<p>当t越大，0.5 ^ t越小，底数就越大，错误率就越大。</p>
</li>
<li><p>用不上Redis4.0怎么办</p>
<p>Redis4.0之前也有第三方的布隆过滤器library，不过实现上，比起Redis的位图，性能差不少。Redis4.0版本的布隆过滤器的可选替代方案。Redis布隆过滤器Python版本的库，名称是pyreBloom。Java版本的库，名称是orestes-bloomfilter。</p>
</li>
<li><p>布隆过滤器的其他应用</p>
<ul>
<li>爬虫系统，需要对URL进行去重，已经爬过的网页就可以不用去爬了。不过也会使得爬虫系统错过少量的页面。</li>
<li>在NoSQL数据库领域使用非常广泛，如HBase、Cassandra，还有LevelDB、RocksDB内部都有布隆过滤器结构，它可以显著降低数据库的IO请求数量。当用户查询某个row时，可以先通过内存中的布隆过滤器过滤掉大量不存在的row请求，然后再去磁盘进行查询。</li>
<li>邮箱系统</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>简单限流</strong> | 断尾求生</p>
<p>限流目的：控制流量（避免请求超过系统的处理能力）和控制用户行为（避免垃圾请求，如用户发帖、回复和点赞行为）。</p>
<ul>
<li><p>如何使用Redis实现简单限流策略</p>
<p>场景：系统要限定用户的某个行为在指定的时间内只能允许发生N次。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># coding: utf-8</span>
<span class="token keyword">import</span> time
<span class="token keyword">import</span> redis

client <span class="token operator">=</span> redis<span class="token punctuation">.</span>StrictRedis<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true"># 指定用户user_id某个行为action_key在特定时间内period只允许发生最多的次数max_count</span>
<span class="token keyword">def</span> <span class="token function">is_action_allowed</span><span class="token punctuation">(</span>user_id<span class="token punctuation">,</span> action_key<span class="token punctuation">,</span> period<span class="token punctuation">,</span> max_count<span class="token punctuation">)</span><span class="token punctuation">:</span>
    key <span class="token operator">=</span> <span class="token string">'hist:%s:%s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>user_id<span class="token punctuation">,</span> action_key<span class="token punctuation">)</span>
    now_ts <span class="token operator">=</span> int<span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 毫秒时间戳</span>
    <span class="token keyword">with</span> client<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> pipe<span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># 记录行为</span>
        <span class="token comment" spellcheck="true"># value和score都使用毫秒时间戳</span>
        mapping <span class="token operator">=</span> <span class="token punctuation">{</span>now_ts<span class="token punctuation">:</span> now_ts<span class="token punctuation">}</span>  <span class="token comment" spellcheck="true"># map中value是key，score是value</span>
        pipe<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span>key<span class="token punctuation">,</span> mapping<span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true"># 移除时间窗口之前的行为记录，剩下的都是时间窗口内的</span>
        pipe<span class="token punctuation">.</span>zremrangebyscore<span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> now_ts <span class="token operator">-</span> period <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true"># 获取窗口内的行为数量</span>
        pipe<span class="token punctuation">.</span>zcard<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true"># 设置zset过期时间，避免冷用户持续占用内存</span>
        <span class="token comment" spellcheck="true"># 过期时间应该等于时间窗口的长度，再多宽限1s</span>
        <span class="token comment" spellcheck="true"># 每次调用expire，都会将key的过期时间更新，因此它不会只在一轮period就删除key。</span>
        pipe<span class="token punctuation">.</span>expire<span class="token punctuation">(</span>key<span class="token punctuation">,</span> period <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true"># 批量执行</span>
        <span class="token comment" spellcheck="true"># pipe.execute()返回一个数组，这里用四个变量接受，下划线表示不重要的变量，第三个参数是我们需要的</span>
        _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> current_count<span class="token punctuation">,</span> _ <span class="token operator">=</span> pipe<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># 比较数量是否超标</span>
    <span class="token keyword">return</span> current_count <span class="token operator">&lt;=</span> max_count

<span class="token comment" spellcheck="true"># 貌似结果不是很精确，有7个返回了true</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># 调用这个接口，一分钟内只允许回复5个帖子</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>is_action_allowed<span class="token punctuation">(</span><span class="token string">"laoqian"</span><span class="token punctuation">,</span> <span class="token string">"reply"</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用pipeline可以显著提升Redis存取效率，但是如果操作量很大如60s内操作超过100万次之类，这就不适合做这样的限流了。</p>
</li>
</ul>
</li>
<li><p><strong>漏斗限流</strong> | 一毛不拔</p>
<p>算法思想就是漏斗，漏斗的剩余空间就代表着当前行为可以持续进行的数量，漏嘴的流水速率代表着系统允许该行为的最大频率。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> time

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
</ol>
<h1 id="占用空间是一个常亮，而不与行为的频率成正比"><a href="#占用空间是一个常亮，而不与行为的频率成正比" class="headerlink" title="占用空间是一个常亮，而不与行为的频率成正比"></a>占用空间是一个常亮，而不与行为的频率成正比</h1><p>   class Funnel(object):</p>
<pre><code>   def __init__(self, capacity, leaking_rate):
       self.capacity = capacity  # 漏斗容量
       self.leaking_rate = leaking_rate  # 漏嘴流水速度
       self.left_quota = capacity  # 漏斗剩余容量
       self.leaking_ts = time.time()  # 上一次漏水时间

   # 漏水 每次灌水前都会被调用以 触发漏水，给漏斗腾出空间。
   def make_space(self):
       now_ts = time.time()
       # 距离上一次漏水过去了多久
       delta_ts = now_ts - self.leaking_ts
       # 腾出的空间 取决于过去了多久以及流水的速率
       delta_quota = delta_ts * self.leaking_rate
       # 腾出空间太少，等下次
       if delta_quota &lt; 1:
           return
           # 增加剩余空间
       self.left_quota += delta_quota
       # 记录漏水时间
       self.leaking_ts = now_ts
       # 剩余空间不得高于容量
       if self.left_quota &gt; self.capacity:
           self.left_quota = self.capacity

   # 进水
   def watering(self, quota):
       self.make_space()
       # 判断剩余空间是否足够
       if self.left_quota &gt;= quota:
           self.left_quota -= quota
           return True
       return False</code></pre><p>   funnels = {}</p>
<p>   def is_action_allowed(user_id, action_key, capacity, leaking_rate):<br>       key = ‘%s:%s’ % (user_id, action_key)<br>       funnel = funnels.get(key)  # 获取漏斗实例<br>       if not funnel:  # funnel返回false时执行 not是逻辑判断词<br>           # 初始化漏斗，一个key对应一个漏斗<br>           funnel = Funnel(capacity, leaking_rate)<br>           funnels[key] = funnel<br>       return funnel.watering(1)</p>
<h1 id="最多进15个"><a href="#最多进15个" class="headerlink" title="最多进15个"></a>最多进15个</h1><p>   for i in range(20):<br>       print(is_action_allowed(“laoqian”, “reply”, 15, 0.5))</p>
<pre><code>
   分布式的漏斗算法如何实现？Funnel对象的内容按字段存储到一个hash结构中，灌水的时候将hash结构的字段取出来进行逻辑运算后，再将新值回填到hash结构中，就完成了一次行为频度的检测。但是，我们无法保证整个过程的原子性。取值、运算和回填三个过程无法原子化，意味着需要加锁，而加锁有可能失败，或重试，影响用户体验。如何解决？Redis-Cell。

   * Redis_Cell https://github.com/brandur/redis-cell

     Redis4.0提供了一个限流Redis模块，叫Redis-Cell。该模块使用了漏斗算法，并提供了原子的限流指令。

     只有一个指令：cl.throttle

     ```mysql
     # laoqian:reply 是key
     # 15 表示漏斗容量
     # 30 60 表示每60秒最多30次，即漏水速率为30/60 （次/秒）
     # 1 可选参数，默认为1
     &gt; cl.throttle laoqian:reply 15 30 60 1
     1) (integer) 0 # 0表示允许，1表示拒绝
     2) (integer) 15 # 漏斗容量
     3) (integer) 14 # 漏斗剩余空间
     4) (integer) -1 # 如果被拒绝，需要多长时间再试，单位秒，这里漏斗还有空间，返回了-1
     5) (integer) 2 # 多长时间后，漏斗完全空出来，单位秒
     ```

   * 扩展

     Redis-Cell使用Rust语言编写的，其作者是Itamar Haber，是Redis工作室的技术布道者。

10. **GeoHash** |  近水楼台

    Redis3.2以后增加了地理位置Geo模块。场景：附近的餐馆，附近的Mobike等。

    * 用数据库来算附近的人

      地图元素位置使用二维经纬度表示，经度范围[-180, 180]，纬度范围[-90, 90]。东正北正。当元素距离不是很大时，可直接使用勾股定理计算，但是经纬坐标密度不一样（地球是个椭圆），需要按一定系数加权计算。

      给定一个元素（x0, y0），如何获取其附近的人？如果时在关系型数据库，可以通过指定一个半径r，获取正方形边长为2r的区域：select id from positions where x0-r &lt; x &lt; x0+r and y0-r &lt; y&lt;y0+r，其中id时元素的唯一标识。数据表可能需要把经纬度坐标加上双向复合索引(x, y)以最大优化查询性能。但是，当查询请求非常多，高并发场合，这并不是很好的方案。

    * GeoHash算法

      业界比较通用的地理位置距离排序算法是GeoHash算法，Redis也是用这个。它将二维的经纬度数据映射到一维的整数。

      它将地球看成一个二维平面，然后划分成一系列正方形的方格，然后再对子方格划分，如此进行下去，方格越小，坐标越精确。然后对这些方格进行编码，比如最开始的四个方格为00，01，10，11，随着方格越小，所需bit数越多，精确度越高。真实算法可能是其他刀法分割，最终编码出来的整数也都不一样。

      编码之后，地图元素变成一个整数，通过这个整数可以还原出元素的坐标，整数越长，还原出来的坐标值损失程度越小。

      GeoHash算法会继续对这个整数做一次base32编码（0~9，a~z，去掉a、i、l、o四个字母）变成一个字符串。在Redis里面，经纬度使用52位的整数进行编码，放进了zset里面，zset的value是元素的key，score是GeoHash的52位整数值。zset的score是浮点数，但对于52位的整数值，可以无损存储。经过实测，redis的score可以达到1.0000000000000001e+300（10^300）这么大。

    * Geo指令基本用法

      Redis提供的Geo指令只有6个。注意它的内部结构是zset。

      增加：geoadd key longitude latitude value

      ```mysql
      127.0.0.1:6379&gt; geoadd company 116.48105 39.996794 juejin
      (integer) 1
      127.0.0.1:6379&gt; geoadd company 116.514203 39.905409 ireader
      (integer) 1
      127.0.0.1:6379&gt; geoadd company 116.489033 40.007669 meituan
      (integer) 1
      127.0.0.1:6379&gt; geoadd company 116.562108 39.787602 jd 116.334255 40.027400 xiaomi
      (integer) 2
      127.0.0.1:6379&gt; 
      ```

      元素删除，使用zrem指令即可

      ```mysql
      127.0.0.1:6379&gt; zrem company juejin
      (integer) 1
      127.0.0.1:6379&gt; geopos company juejin
      1) (nil)
      127.0.0.1:6379&gt; 
      ```

      距离：geodist key value1 value2 UnitOfDistance，计算两个元素之间的距离，单位可以是m（米）、km（千米）、ml（英里）和ft（尺）。

      ```mysql
      127.0.0.1:6379&gt; geodist company juejin ireader km
      &quot;10.5501&quot;
      127.0.0.1:6379&gt; geodist company juejin meituan km
      &quot;1.3878&quot;
      127.0.0.1:6379&gt; geodist company juejin jd km
      &quot;24.2739&quot;
      127.0.0.1:6379&gt; geodist company juejin xiaomi km
      &quot;12.9606&quot;
      127.0.0.1:6379&gt; geodist company juejin juejin km
      &quot;0.0000&quot;
      ```

      获取元素的位置：geopos company value1 value2，可以一次获取多个

      ```mysql
      127.0.0.1:6379&gt; geopos company juejin
      1) 1) &quot;116.48104995489120483&quot;
         2) &quot;39.99679348858259686&quot;
      127.0.0.1:6379&gt; geopos company juejin ireader
      1) 1) &quot;116.48104995489120483&quot;
         2) &quot;39.99679348858259686&quot;
      2) 1) &quot;116.5142020583152771&quot;
         2) &quot;39.90540918662494363&quot;
      # 可以看出获取到的和geoadd进去的坐标有少许误差，因为GeoHash对二维坐标进行的一维映射是有损的。
      ```

      获取元素的hash值：geohash key value1 value2，可以一次获取多个

      ```mysql
      127.0.0.1:6379&gt; geohash company juejin
      1) &quot;wx4gd94yjn0&quot;
      127.0.0.1:6379&gt; 
      127.0.0.1:6379&gt; geohash company juejin ireader
      1) &quot;wx4gd94yjn0&quot;
      2) &quot;wx4g52e1ce0&quot;
      # 获取元素的经纬度编码字符串，它是base32编码，可以在http://geohash/org/${hash}上直接定位。
      ```

      查询指定元素附近的其他元素：

      georadiusbymember key value distance Unit [withcoord|withdist|withhash] count num [desc|asc]

      ```mysql
      # 范围20公里以内最多3个元素按距离正排，不会排除自身
      127.0.0.1:6379&gt; georadiusbymember company ireader 20 km count 3 asc
      1) &quot;ireader&quot;
      2) &quot;juejin&quot;
      3) &quot;meituan&quot;
      # 范围20公里以内最多3个元素按距离倒排
      127.0.0.1:6379&gt; georadiusbymember company ireader 20 km count 3 desc
      1) &quot;jd&quot;
      2) &quot;meituan&quot;
      3) &quot;juejin&quot;
      # 三个可选参数withcoord（显示经纬度Coordinates）,withdist（显示距离）,withhash用来携带附加参数。
      127.0.0.1:6379&gt; georadiusbymember company ireader 20 km withcoord withdist withhash count 3 asc
      1) 1) &quot;ireader&quot;
         2) &quot;0.0000&quot; # 距离
         3) (integer) 4069886008361398 # hash
         4) 1) &quot;116.5142020583152771&quot; # 经度
            2) &quot;39.90540918662494363&quot; # 纬度
      2) 1) &quot;juejin&quot;
         2) &quot;10.5501&quot;
         3) (integer) 4069887154388167
         4) 1) &quot;116.48104995489120483&quot;
            2) &quot;39.99679348858259686&quot;
      3) 1) &quot;meituan&quot;
         2) &quot;11.5748&quot;
         3) (integer) 4069887179083478
         4) 1) &quot;116.48903220891952515&quot;
            2) &quot;40.00766997707732031&quot;
      ```

      查询指定坐标附近的元素：类似查询指定元素的指令

      georadius key longitude latitude distance Unit [withcoord|withdist|withhash] count num [desc|asc]

      ```mysql
      127.0.0.1:6379&gt; georadius company 116.514202 39.905409 20 km withdist count 3 asc
      1) 1) &quot;ireader&quot;
         2) &quot;0.0000&quot;
      2) 1) &quot;juejin&quot;
         2) &quot;10.5501&quot;
      3) 1) &quot;meituan&quot;
         2) &quot;11.5748&quot;
      ```

    * 注意事项

      在Redis集群环境中，集合可能会从一个节点迁移到另一个节点，如果单个key的数据过大，会对集群的迁移工作造成较大的影响，集群环境中单个key对应的数据不宜超过1MB，否则会导致集群迁移出现卡顿现象，影响线上服务的正常运行。作者建议，Geo的数据使用单独的Redis实例部署，不使用集群环境。

      如果数据量过亿，甚至更大，就需要对Geo数据进行拆分，可以按国家拆分、按省拆分、按市拆分。这样可以显著降低单个zset集合的大小。

11. **scan** | 大海捞针

    需求：找出特定前缀的key列表，修改它的值或删除key。

    方式一：keys 正则表达式

    缺点：没有offset、limit参数，一次性吐出所有满足条件的key。keys是遍历算法，复杂度是O(n)，易导致Redis服务卡顿。

    ```mysql
    127.0.0.1:6379&gt; keys *
    1) &quot;codehole&quot;
    2) &quot;company&quot;
    127.0.0.1:6379&gt; keys com
    (empty list or set)
    127.0.0.1:6379&gt; keys com*
    1) &quot;company&quot;
    127.0.0.1:6379&gt; keys *ny
    1) &quot;company&quot;
    ```

    方式二：Redis2.8加入了scan指令

    特点：复杂度是O(n)，但是它是通过游标分步进行的，不会阻塞线程。提供limit参数，提供模式匹配功能。返回的结果可能有重复，需要客户端去重。遍历的过程中如果有数据修改，改动后的数据不能遍历到是不确定的。单次返回的结果是空并不意味着遍历结束，而要看返回的游标值是否为零。

    * scan基本用法

      模拟数据

      ```python
      # coding: utf-8
      import redis

      client = redis.StrictRedis()
      # 测试scan，模拟大量数据
      for i in range(10000):
          client.set(&quot;key%d&quot; % i, i)
      ```

      scan cursor match 正则模式 count limit

      cursor：游标整数值，一开始从0开始，下一次是以上一次返回的游标值为起始游标，直至返回0即遍历结束。limit是单次遍历的字典槽位数量（约等于），不是返回的key的个数。可以看出一万的数据量，limit为1000时，遍历10遍即可。

      ```mysql
      127.0.0.1:6379&gt; scan 0 match key99 count 1000
      1) &quot;6936&quot;
      2) (empty list or set)
      127.0.0.1:6379&gt; scan 6936 match key99 count 1000
      1) &quot;5004&quot;
      2) (empty list or set)
      127.0.0.1:6379&gt; scan 5004 match key99 count 1000
      1) &quot;12498&quot;
      2) (empty list or set)
      127.0.0.1:6379&gt; scan 12498 match key99 count 1000
      1) &quot;6822&quot;
      2) (empty list or set)
      127.0.0.1:6379&gt; scan 6822 match key99 count 1000
      1) &quot;14849&quot;
      2) 1) &quot;key99&quot;
      127.0.0.1:6379&gt; scan 14849 match key99 count 1000
      1) &quot;8281&quot;
      2) (empty list or set)
      127.0.0.1:6379&gt; scan 8281 match key99 count 1000
      1) &quot;13197&quot;
      2) (empty list or set)
      127.0.0.1:6379&gt; scan 13197 match key99 count 1000
      1) &quot;10195&quot;
      2) (empty list or set)
      127.0.0.1:6379&gt; scan 10195 match key99 count 1000
      1) &quot;7591&quot;
      2) (empty list or set)
      127.0.0.1:6379&gt; scan 7591 match key99 count 1000
      1) &quot;0&quot;
      2) (empty list or set)
      ```

    * 字典的结构

      Redis中所有的key都存在一个很大的字典中，类似Java的HashMap，它是一维数组，二维链表结构，第一维数组大小总是2^n(n&gt;=0)，扩容一次，空间加倍，即2^(n+1)。

      scan指令返回的游标就是第一维数组的位置索引（称为槽slot）。limit参数就表示需要遍历的槽位数，由于槽位上挂接的链表元素可能是空可能是多个，因此，返回的结果可能多可能少了。

    * scan遍历顺序

      它不是从第0位一直遍历到末尾，而是采用了高位进位加法来遍历，这是因为考虑到字典的扩容和缩容时避免槽位的遍历重复和遗漏。

      普通加法：0000-&gt;0001-&gt; 0010-&gt;0011，加1

      高位进位加法：0000-&gt;1000-&gt;0100-&gt;1100，加1

    * 字典扩容

      扩容都是加倍，缩容就是减倍，同时需要将所有元素全部rehash到新数组上。rehash就是将元素的hash值对数组长度进行取模运算，由于长度变了，所以每个元素挂接的槽位可能也发生了变化。又由于数组的长度是2^n，所以取模运算等价于位与运算。

      ```
      a mod 8 = a &amp; (8 - 1) = a &amp; 7 
      a mod 16 = a &amp; (16 - 1) = a &amp; 15 
      a mod 32 = a &amp; (32 - 1) = a &amp; 31
      这里7、5、31称为mask值，作用就是保留hash值的低位，高位设为0.
      ```

      用高位进位加法的理论支持：

      假设数组长度由8位扩容到16位，那么3号槽011将会被rehash到3号槽位和11号槽位（原来的11在长度为8时取模为3，在长度为16时取模为11），也就是说该槽位大约一半在原来槽位，一半在新的槽位。11这个数字的二进制是1011，就是对3的二进制011增加了一个高位。

      抽象来看，8-&gt;16，槽位二进制数是xxx，rehash后成为0xxx和1xxx。

      16-&gt;32，槽位二进制数是xxxx，rehash后成为0xxxx和1xxxx。

    * 对比扩容、缩容前后的遍历顺序

      按照高位进位加法的遍历顺序：

      ```
      缩容：00-&gt;10-&gt;01-&gt;11
      当前：[000-&gt;100]-&gt;[010-&gt;110]-&gt;[001-&gt;101]-&gt;[011-&gt;111]
      扩容：[0000-&gt;1000]-&gt;[0100-&gt;1100]-&gt;[0010-&gt;1010]-&gt;[0110-&gt;1110]-&gt;[0001-&gt;1001]-&gt;[0101-&gt;1101]-&gt;[0011-&gt;1011]-&gt;[0111-&gt;1111]
      ```

      假设当前要遍历110这个位置，扩容后，槽位变成0110和1110（高位增加1或0）。这时我们可以直接从0110这个槽位开始往后继续遍历，0110之前的槽位都是已经遍历过得（即使是映射到新槽位的元素，它还是在当前遍历点的前面，因为新槽位和原来的槽位相邻），因此不会重复遍历元素。

      再考虑缩容，槽位变成了10（减去一高位），我们可以直接从10这个槽位继续往后遍历，这里只重复遍历了10这个槽位，但10之前的元素都不会重复遍历。

    * 渐进式rehash

      简介见之前的hash基本结构。

      操作处于rehash中的字典，需要同时访问新旧两个数据结构。如果旧数组中找不到元素，还需要去新数组下面寻找。

      scan也需要考虑这个问题，对于rehash中的字典，需要同时扫描新旧槽位，然后将结果融合返回给客户端。

    * 更多的scan指令

      scan指令是一系列指令。除了遍历所有的key，还可以对指定容器集合进行遍历。如zscan遍历zset，hscan遍历hash，sscan遍历set。它们的原理类似scan，因为hash底层就是字典，set是一个特殊的hash（所有的value指向同一个元素），zset内部也使用了字典来存储所有的元素内容。

    * 大key扫描

      集群情况，key太大，会导致数据迁移卡顿。内存分配上，如果key太大，当需要扩容时，会一次性申请更大的内存，这也会导致卡顿。如果大key被删除，内存会被一次性回收，也会导致卡顿。

      **平时业务开发中，尽量避免大key的产生。**

      如果观察到Redis内存大起大落，这很可能是大key导致的。

      定位大key：

      脚本方式：scan扫描每一个key，使用type指令获取key类型，然后使用相应数据结构的size或者len得到大小，将大小排名的前若干名作为扫描结果展示出来。

      Redis类似扫描功能指令方式：

      不加-i 0.1参数容易抬升Redis的ops导致线上报警。

      redis-cli -h 127.0.0.1 -p 7001 --bigkeys -i 0.1

      每隔100条scan指令就会休眠0.1s，ops就不会剧烈台上抬升，但是扫描时间会变长。

## 二、原理篇

1. **线程IO模型** | 鞭辟入里

   Redis是个单线程，另外像Node.js，Nginx也是单线程，它们都是服务器高性能的典范。why快？因为它们的数据都存在内存中。对于O(n)级别的指令需要小心使用。对于单线程，如何处理高并发的客户端连接？多路复用，select系列事件轮询API，非阻塞IO。

   * 非阻塞IO

     套接字默认的读写方法是阻塞的，也就是说当读的时候会传入一个参数n，表示读到n个字节后返回，没读到就阻塞。写的时候，写缓冲如果满了，写方法也就阻塞了。

     非阻塞IO的套接字对象上提供了一个选项Non_Blocking，即读的时候，读缓冲有多少就读多少，写的时候，写缓冲有多少空闲空间就写多少数据。读写方法返回值表示读写了多少字节。

   * 事件轮询（多路复用）

     非阻塞IO的问题：线程读了一部分就返回，线程何时才继续读？写的时候，缓冲区满了，如何继续写？我们应该让数据到读缓冲时或写缓冲有空闲时通知线程，让线程继续进行读写操作。

     如何解决？使用事件轮询的方式。

     select函数（操作系统提供给用户程序的API）就是一个事件轮询API。select系统调用能同时处理多个通道描述符的读写事件，这类系统调用称为多路复用API。现代OS使用epoll（Linux）、kqueue（FreeBSD和macosx），而不是select（在描述符特别多时性能会变差）

     ```python
     # 参数：
     #     读写描述符列表：read_fds，write_fds；客户端描述符会放在列表里面。
     #     超时时间：timeout 如果没有任何事件到来，最多等待timeout时间，线程在这里阻塞。
     # 返回值：与之对应的可读可写事件。（当有事件到来或已经超时就立即返回）
     read_events, write_events = select(read_fs, write_fds, timeout)
     for event in read_events:
         handle_read(event.fd)  # 处理读事件，也就是说可以继续读了
     for event in write_events:
         handle_write(event.fd)
     handle_others() # 处理其他事情，如1定时任务
     # 处理完了继续轮询，线程进入一个死循环，这个死循环称为事件循环，一个循环为一个周期
     ```

     Java中的事件轮询API有NIO技术。

   * 指令队列

     Redis会将客户端套接字都关联到一个指令队列。客户端的指令通过队列来排队进行顺序处理。

   * 响应队列【暂未很好理解】

     Redis会将客户端套接字都关联到一个响应队列。Redis服务器通过响应队列将指令的返回结果回复给客户端。如果队列为空，意味着连接暂时处于空闲状态，不需要获取写事件（为什么这里没说读事件？个人认为Redis这里关注的是将数据回复给客户端，也就是Redis线程要获取写事件，将数据写到写缓冲区，让后让客户端去读取数据。），可以将当前的客户端描述符从write_fds里移出来。等到队列有数据了，再将描述符放进去，避免select系统调用立即返回写事件，结果发现没什么数据可以写。

   * 定时任务

     服务器除了响应IO事件外，还要处理其他事情，如定时任务。

     Redis的定时任务是记录在一个最小堆中，最快要执行的任务最堆顶。在每个循环周期，Redis都会对最小堆里面已经到时间点的任务进行处理。处理完毕后，将最快要执行的任务（堆顶任务）还需要的时间（比如现在是3点，它执行时间点是4点，那么这个时间差就是1个小时），这个时间就是select系统调用的timeout参数。因为这样，可以在这个时间差去做select操作。Nginx和Node事件处理原理类似。

2. **通信协议** | 交头接耳

   Redis作者认为数据库系统的瓶颈在于数据库自身内部逻辑处理上，不在于网络流量。单线程对外提供服务，单个节点在跑满一个CPU核心的情况可以达到10w/s的QPS

   * RESP（Redis Serialization Protocol，Redis序列化协议）

     优点：实现过程简单，解析性能极好。

     RESP将传输的数据结构分为5种最小单元类型，单元结束时统一加上回车换行符号\r\n。

     * 单行字符以“+”开头

       ```
       +hello world\r\n
       ```

     * 多行字符以“$”开头，后跟字符串长度。

       ```
       多行字符可表示单行字符。
       $11\r\nhello world\r\n
       NULL用多行字符串表示，长度要写成-1。
       $-1\r\n
       空串用多行字符串表示，长度填0。两个\r\n之间是空串。
       $0\r\n\r\n
       ```

     * 整数值以“:”开头，后跟整数的字符串形式

       ```
       :1024\r\n
       ```

     * 错误消息以“-”开头

       ```
       参数类型错误
       -WRONGTYPE Operation against a key holding the wrong kind of value\r\n
       ```

     * 数组以&quot;*&quot;开头，后跟数组的长度

       ```
       数组[1,2,3]
       *3\r\n:1\r\n:2\r\n:3\r\n
       ```

       开头或\r\n到下一个\r\n就是一个单元。

   * 客户端 -&gt; 服务器

     客户端向服务器发送的指令只有一种格式，即多行字符串数组。

     ```
     如set author codehole指令会被序列化成如下字符串
     *3\r\n$3\r\nset\r\n$6\r\nauthor\r\n$8\r\ncodehole\r\n
     有三个字符串，即长度为3的数组。第一个字符串长度为3，内容为set，后面的类似。
     ```

   * 服务器 -&gt; 客户端

     Redis incr命令将 key 中储存的数字值增一。

     如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行incr操作。

     如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误 ERR，ERR hash value is not an integer。

     本操作的值限制在 64 位(bit)有符号数字表示之内。

     **Note**: 本质上这是一个字符串操作，因为Redis没有专门的整数类型。存储在 key 中的字符串被转换为十进制有符号整数，在此基础上加1

     * 单行字符串响应

       ```mysql
       127.0.0.1:6379&gt; set author codehole
       OK # 这个OK就是单行响应，没有使用引号括起来，对应：
       +OK
       ```

     * 错误响应

       ```mysql
       127.0.0.1:6379&gt; incr author
       (error) ERR value is not an integer or out of range # 试图对一个字符串进行自增，服务器抛出一个通用的错误。对应：
       -ERR value is not an integer or out of range
       ```

     * 整数响应

       ```mysql
       127.0.0.1:6379&gt; incr books
       (integer) 1 # 这里的1就是整数响应，对应：
       :1
       ```

     * 多行字符串响应

       ```mysql
       127.0.0.1:6379&gt; get author
       &quot;codehole&quot; # 这里用双引号括起来的字符串就是多行字符串响应，对应：
       $8
       codehole
       ```

     * 数组响应

       ```mysql
       127.0.0.1:6379&gt; hset info name laoqian
       (integer) 1
       127.0.0.1:6379&gt; hset info age 30
       (integer) 1
       127.0.0.1:6379&gt; hset info set male
       (integer) 1
       127.0.0.1:6379&gt; hgetall info # hgetall命令返回的就是一个数组，客户端负责将数组组装成字典再返回
       1) &quot;name&quot; # hash表的key
       2) &quot;laoqian&quot; # hash表的value
       3) &quot;age&quot;
       4) &quot;30&quot;
       5) &quot;set&quot;
       6) &quot;male&quot;
       对应：
       *6
       $4
       name
       $6
       laoqian
       $3
       age
       $2
       30
       $3
       sex
       $4
       male
       ```

     * 嵌套

       ```mysql
       127.0.0.1:6379&gt; scan 0 # scan 0 表示扫描所有key列表
       1) &quot;0&quot; # 表示游标的值，这里是0表示遍历完毕
       2) 1) &quot;author&quot; # 这个数组就是key列表
          2) &quot;info&quot;
          3) &quot;books&quot;
       对应：
       *2 # 数组大小为2
       $1 # 第一个元素的多行字符串长度为1
       0 # 值为0
       *3 # 子数组大小为3
       $6
       author
       $4
       info
       $5
       books
       ```

   * 小结

     尽管Redis协议有大量冗余的回车换行符，但它简单，易理解和易实现。有很多开源项目使用RESP协议。在技术领域，性能并不总是一切。

3. **持久化** | 未雨绸缪

   问题场景：Redis的数据全部在内存里，如果突然宕机，数据就会全部丢失，需要一种机制保证数据不会因为故障而丢失。这就有了Redis的持久化机制。

   两种机制：快照和AOF日志。

   **快照**：是一种全量备份，是内存数据的二进制序列化形式，在存储上非常紧凑。

   **AOF日志**：是连续的增量备份，记录的是内存数据修改的指令记录文本。长期运行过程中，AOF会变的很大，需要定期进行AOF重写，给AOF日志进行瘦身。

   * 快照原理

     一些问题：Redis是单线程的，内存快照要求进行文件IO操作，但文件IO不能使用多路复用API，耗时严重会严重拖累服务器性能。还有就是如果持久化的同时，内存数据结构还在变化，持久化该怎么办？

     Redis使用操作系统的多进程COW（Copy On Write）机制来实现快照持久化。

   * fork（多进程）

     Redis在持久化时会调用glibc的函数fork产生一个子进程，这个子进程负责快照持久化，父进程继续处理客户端请求。子进程刚刚产生时，它和父进程共享内存里面的代码段和数据段。这是Linux操作系统的机制。在进程分离的一瞬间，内存的增长几乎没有明显变化。

     用Python描述进程分离逻辑：

     ```python
     # fork函数会在父子进程同时返回，在父进程离返回子进程的pid，子进程里返回零。如果os的内存资源不足，pid就是负数，表示fork失败。
     pid = os.fork()
     if pid &gt; 0:
         handle_client_requests() # 父进程继续处理客户端请求
     if pid == 0:
         handle_snapshot_write() # 子进程处理快照写磁盘
     if pid &lt; 0:
         # fork error
     ```

     子进程做数据化持久，只是对数据结构进行遍历读取，然后序列化写到磁盘中，不会修改现有的内存数据结构。

     父进程会持续服务客户端请求，然后对内存数据结构进行不间断的修改。操作系统的COW机制会进行数据段页面分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面数据进行修改时，会将被共享的页面复制一份分离出来，然后对这个复制的页面进行修改。子进程的页面始终是固定的。随着父进程修改操作持续进行，越来越多的共享页面分离出来，内存就会持续增长，但不会超过原来的数据内存的2倍。另外，Redis实例里冷数据占得比例往往比较高，所以很少出现所有页面都被分离的情况，导致数据内存翻倍。

     总而言之，这个COW机制，就是在修改的时候，复制修改数据所在页出来，这样既不影响持久化，也不影响处理客户端请求。

   * AOF原理

     AOF日志存储的是Redis服务器的顺序指令序列，AOF日志只记录对内存进行修改的指令记录。

     假设AOF日志记录了Redis实例自创建来所有的指令序列，那么可以通过对一个空的Redis实例顺序执行所有指令，来恢复Redis当前实例的内存数据结构状态。

     Redis会在收到客户端修改指令后，进行参数校验、逻辑处理，如果没问题，才将它存储到AOF日志。不同于leveldb、hbase等存储引擎，它们是先存储到日志再做逻辑处理。

   * AOF重写（Redis运行过程中，AOF会越来越长，需要对AOF瘦身）

     Redis提供了bgrewriteof指令用于对AOF日志进行瘦身。

     瘦身原理：

     开辟一个子进程对内存进行遍历，转换成一系列Redis操作指令（这里可能就瘦身了，个人理解就是原来的指令序列造成了现在的内存结构，但指令序列会有重复或回到原点的情况，这样就可以减少不必要的指令序列，这个内存转换得到的指令，反过来可以还原成内存的结构），序列化到一个新的AOF日志文件中。序列化完毕后再将操作期间发生的增量AOF日志追加到这个新的AOF日志文件中，追加完毕后就立即替代旧的AOF日志文件，瘦身工作就完成了。

   * fsync

     AOF日志是以文件形式存在的，当程序对AOF日志文件进行写操作时，实际上是将内容写到了内核为文件描述符分配的一个内存缓存中，然后内核会异步（可能造成延迟很久才刷回）将脏数据刷回到磁盘。

     如果机器宕机，AOF日志可能丢失，即没来的及刷回磁盘。怎么办？

     Linux的glibc提供了fsync(int fd)函数可以将指定的文件内容强制从内核缓存刷到磁盘。只要Redis进程实时调用fsync，可以保证AOF日志不丢失，但是IO操作慢，需要指定一个频率，一般是每隔1s左右执行一次fsync操作，这个周期是可以配置的，极端情况：来一个指令调用一次或永不调用（让操作系统决定何时同步磁盘），两种极端情况都不可取。

   * 运维

     快照是通过开启子线程方式进行的，它是一个比较耗资源的操作。AOF的fsync是一个耗时IO操作，它会降低Redis性能。

     因此Redis的主节点一般不会进行持久化操作，持久化操作主要在从节点进行。从节点是备份节点，没有来自客户端请求的压力。

     如果出现网络分区，从节点长期连不上主节点，就会出现数据不一致的问题。因此生产环境要做好实时监控，保证网络畅通或者能快速修复。增加从节点可以降低网络分区的概率。

   * Redis4.0混合持久化

     重启Redis时，一般不使用rdb恢复内存状态，因为会丢失大量数据（快照持久化期间会有新的指令过来），通常使用AOF日志重放，但是重放在Redis实例很大时会花费很长时间。

     将rdb文件（快照）的内容和增量的AOF日志文件存在一起。这个AOF日志不是全量的，而是自持久化开始到持久化结束这段时间发生的增量AOF日志。

     在Redis重启的时候，可以先加载rdb的内容，然后再重放AOF日志。

4. **管道** | 雷厉风行

   Redis管道（Pipeline）本身并不是Redis服务器直接提供的技术，而是客户端提供的。

   * Redis的消息交互

     正常情况：client请求，Redis响应，Client请求，Redis响应。会花费多个网络数据包来回时间。在客户端代码层面，客户端经历过了写-读-写-读四个操作完整地执行了两条指令。

     调整读写顺序，改成写-写-读-读，多个连续的写操作只花费一次网络来回，效果上看是写操作合并，读操作合并了。这就是管道操作的本质。客户端通过对管道中的指令列表改变读写顺序可以大幅节省IO时间。管道中指令越多，效果越好。

     服务器根本没有任何区别对待，还是收到一条消息，执行一条消、回复一条消息的正常流程。

   * 管道压力测试

     Redis自带的压力测试工具redis-benchmark，它可以用来进行管道测试。

     ```mysql
     wuyoupeng@wuyoupeng:~$ redis-benchmark -t set -q # 普通set指令
     SET: 76863.95 requests per second # QPS大约7w/s
     wuyoupeng@wuyoupeng:~$ redis-benchmark -t set -P 2 -q # -P 2表示管道并行的请求数量，P=2
     SET: 149925.03 requests per second # QPS大约14w/s
     wuyoupeng@wuyoupeng:~$ redis-benchmark -t set -P 3 -q
     SET: 217391.30 requests per second
     wuyoupeng@wuyoupeng:~$ redis-benchmark -t set -P 4 -q
     SET: 294985.25 requests per second
     wuyoupeng@wuyoupeng:~$ redis-benchmark -t set -P 5 -q
     SET: 387596.91 requests per second
     wuyoupeng@wuyoupeng:~$ redis-benchmark -t set -P 6 -q
     SET: 377358.50 requests per second
     wuyoupeng@wuyoupeng:~$ redis-benchmark -t set -P 7 -q
     SET: 546448.06 requests per second
     wuyoupeng@wuyoupeng:~$ redis-benchmark -t set -P 8 -q
     SET: 636942.62 requests per second
     wuyoupeng@wuyoupeng:~$ redis-benchmark -t set -P 9 -q
     SET: 460829.50 requests per second
     wuyoupeng@wuyoupeng:~$ redis-benchmark -t set -P 10 -q
     SET: 571428.56 requests per second
     wuyoupeng@wuyoupeng:~$ redis-benchmark -t set -P 11 -q
     SET: 746268.62 requests per second
     wuyoupeng@wuyoupeng:~$ redis-benchmark -t set -P 12 -q
     SET: 645161.31 requests per second
     wuyoupeng@wuyoupeng:~$ redis-benchmark -t set -P 13 -q
     SET: 729927.06 requests per second
     wuyoupeng@wuyoupeng:~$ redis-benchmark -t set -P 14 -q
     SET: 757575.75 requests per second # QPS大约75w/s
     wuyoupeng@wuyoupeng:~$ redis-benchmark -t set -P 15 -q
     SET: 740740.69 requests per second
     wuyoupeng@wuyoupeng:~$ redis-benchmark -t set -P 16 -q
     SET: 740740.69 requests per second
     # 随着并行数量增加，QPS会达到顶峰，这是因为Redis的单线程CPU消耗已经达到极限了。
     ```

   * 深入理解管道本质

     客户端：

     Client -&gt; request -&gt; （内核kernel：send buffer -&gt; NIC[network interface card，网卡]） -&gt; Gateway Router（网际路由）-&gt; 请求服务端 -&gt;  服务端通过网际路由返回响应 -&gt;（内核：NIC -&gt; recv buffer ）-&gt; Client

     1、客户端进程调用write将消息写到操作系统内核为套接字分配的发送缓冲send buffer中。

     2、客户端操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过网际路由发送到服务器的网卡。

     7、客户端操作系统内核将网卡的数据放到内核为套接字分配的接受缓冲recv buffer中。

     8、客户端进程内核调用read接受缓冲中取出消息返回给上层业务逻辑进行处理。

     服务端：

     3、服务器操作系统内核将网卡的数据放到内核为套接字分配的接受缓冲recv buffer中。

     4、服务器进程调用read从接受缓冲取出消息进行处理。

     5、服务器进程调用write将响应消息写到内核为套接字分配的发送缓冲send buffer中。

     6、服务器操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过网际路由发送到客户端的网卡。

     Geteway Router -&gt; （Kernel：NIC -&gt; recv buffer） -&gt; request -&gt; Server -&gt; response -&gt; （Kernel：send buffer -&gt; NIC） -&gt; Gateway Router -&gt;回复客户端。

     write操作只负责将数据写到发送缓冲，然后就返回，操作系统内核会异步将数据送到目标机器。如果发送缓冲满了，write就阻塞，就产生IO耗时了。

     read操作只负责从接受缓冲取出数据，如果缓冲为空，read阻塞，产生IO耗时。

     对于value = redis.get(key)这个请求，write基本没有耗时，直接写到发送缓冲就返回，而read就比较耗时，他需要等待消息经过网络路由到目标机器处理后的响应消息，再回送到当前内核缓冲才可以返回。

     对于管道来说，连续的write操作根本不耗时，之后第一个read操作会等待一个网络来回开销，然后所有的响应消息都已经送到内核读缓冲，后续read操作直接从缓冲拿即可。

5. **事务** | 同舟共济

   为什么要事务？确保连续多个操作的原子性。Redis的事务模型是不严格的，不能像使用关系数据库的事务一样使用Redis事务。

   * Redis事务的基本用法

     一般事务形式：

     ```java
     begin(); // 事务的开始
     try {
         command1();
         command2();
         ...
         commit(); // 事务的提交
     } catch (Exception e) {
         rollback(); // 事务的回滚
     }
     ```

     Redis事务指令：

     multi：事务的开始

     exec：事务的执行，所有的指令在exec之前不执行，而是缓存在服务器的一个事务队列中。

     discard：事务的丢弃

     服务器收到exec指令才开始执行整个事务，执行完毕后一次性返回所有指令的运行结果。Redis是单线程，不用担心执行队列的时候被其他指令大打搅，可以保证“原子性”（注意这个引号，他不是常规事务的原子性）。

     ```mysql
     127.0.0.1:6379&gt; multi
     OK
     127.0.0.1:6379&gt; incr books
     QUEUED # 表示指令已经被服务器缓存到队列里了。
     127.0.0.1:6379&gt; incr books
     QUEUED
     127.0.0.1:6379&gt; exec
     1) (integer) 1
     2) (integer) 2
     ```

   * 原子性

     ```mysql
     127.0.0.1:6379&gt; multi
     OK
     127.0.0.1:6379&gt; set books &quot;i am a string&quot;
     QUEUED
     127.0.0.1:6379&gt; incr books
     QUEUED
     127.0.0.1:6379&gt; set poorman &quot;i am desperate&quot;
     QUEUED
     127.0.0.1:6379&gt; exec
     1) OK
     2) (error) ERR value is not an integer or out of range
     3) OK
     127.0.0.1:6379&gt; get books
     &quot;i am a string&quot;
     127.0.0.1:6379&gt; get poorman
     &quot;i am desperate&quot;
     ```

     可以看出Redis不具备“原子性”，而仅仅是满足了事务的“隔离性”中的串行化（即当前执行的事务不被其他事物打断的权利）

   * discard（丢弃）：丢失事务缓存队列中的所有指令，在exec执行之前使用。

     ```mysql
     127.0.0.1:6379&gt; get books
     (nil)
     127.0.0.1:6379&gt; multi
     OK
     127.0.0.1:6379&gt; incr books
     QUEUED
     127.0.0.1:6379&gt; incr books
     QUEUED
     127.0.0.1:6379&gt; get books
     QUEUED
     127.0.0.1:6379&gt; discard # 丢弃这次事务和事务中的指令
     OK 
     127.0.0.1:6379&gt; exec # 没有事务执行，报错
     (error) ERR EXEC without MULTI
     127.0.0.1:6379&gt; get books # 事务中的指令未被执行
     (nil)
     ```

   * 优化

     Redis事务发送每个指令到事务缓存队列都要经过一次网络读写，当指令很多时，会比较耗时，一般Redis客户端在执行事务的时候都会结合管道（pipeline）一起使用。如Python的Redis客户端：

     ```python
     pipe = redis.pipeline(transaction=true) # 执行事务时强制使用pipeline
     pipe.multi()
     pipe.incr(&quot;books&quot;)
     pipe.incr(&quot;books&quot;)
     values = pipe.execute()
     ```

   * watch，一种乐观锁

     悲观锁：基于悲观态度来防止一切数据冲突，修改前加锁，修改完释放锁，期间其他线程不能访问被锁的数据。能够保证数据正确，但性能不高。认为写多读少。

     乐观锁：对于数据冲突保持乐观态度，允许并发操作数据，只是到数据提交的时候才通过一种机制验证数据是否存在冲突。本身不对数据加锁，而是通过业务实现加锁和解锁的过程。性能好。认为读多写少。

     场景：两个并发的客户端需要对某个数据进行修改操作，比如对某个整数加倍，Redis没有提供这样的原子操作，我们需要取出数据然后在内存中加倍，再将结果写回Redis。这里就有可能产生client1读-&gt;client2读-&gt;client1写-&gt;client2写的并发操作，导致数据错误。

     watch使用方式：

     ```python
     while True:
         do_watch() # watch会在事务开始之前盯住一个或多个关键变量
         commands()
         multi()
         send_commands()
         try:
             exec() # 事务执行时，Redis会检查关键变量自watch之后是否被修改了（这里准确来说应该是自watch到事务开始之间吧？下面事务执行成功的例子可以说明这一点。
             break
         except WatchError: # 如果关键变量被人动过了，exec指令就会返回NULL回复告知客户端事务执行失败。客户端一般会选择重试。
             continue
     ```

     ```mysql
     127.0.0.1:6379&gt; watch books
     OK
     127.0.0.1:6379&gt; incr books # 被修改了（可能是当前客户端或其他客户端的操作）
     (integer) 1
     127.0.0.1:6379&gt; multi
     OK
     127.0.0.1:6379&gt; incr books
     QUEUED
     127.0.0.1:6379&gt; exec # 事务执行失败
     (nil)
     -----------------------
     127.0.0.1:6379&gt; watch books
     OK
     127.0.0.1:6379&gt; multi
     OK
     127.0.0.1:6379&gt; incr books
     QUEUED
     127.0.0.1:6379&gt; exec # 事务执行成功
     1) (integer) 1
     ```

     exec执行失败会返回给客户端一个错误，如redis-py返回WatchError之类，Java的Jedis返回NULL。

   * 注意事项

     Redis禁止在multi和exec之间（即事务内）执行watch指令，必须在multi之前（即事务开前）盯住关键变量，否则报错。

     ```python
     import redis


     def key_for(user_id):
         return &quot;account_{}&quot;.format(user_id)


     def double_account(client, user_id):
         key = key_for(user_id)
         while True:
             client.watch(key)  # 盯住这个key
             value = int(client.get(key))
             value *= 2  # 加倍
             pipe = client.pipeline(transaction=True)
             pipe.multi()
             pipe.set(key, value)
             try:
                 pipe.execute()
                 break  # 事务执行成功
             except redis.WatchError:
                 continue  # 事务被打断，重试
         return int(client.get(key))


     client = redis.StrictRedis()
     user_id = &quot;abc&quot;
     client.setnx(key_for(user_id), 5)  # setnx 初始化
     print(double_account(client, user_id)) # 结果是10
     ```

6. **PubSub** | 小道消息

   Redis消息队列本身不支持消息的多播机制，但是它使用了一个模块PubSub可以支持消息多播。

   普通的消息队列：将多个不同的消费组逻辑串接起来放在一个子系统，进行连续消费。

   Publisher ---send---&gt;（消息队列）[0,1,2,3...]---recv---&gt;Consumer1---&gt;Consumer2---&gt;Consumer3

   消息多播：允许生产者生产一次消息，由中间件负责将消息复制到多个消息队列，每个消息队列由相应的消费组进行消费。它是分布式系统常用的一种解耦方式，用于将多个消费组的逻辑进行拆分。这样多个消费组的逻辑就可以放到不同的子系统中。

   Publisher---send---&gt;（中间件）---&gt;（多个消息队列）---&gt;（多个消费组，对应各自的消息队列）

   * PubSub，PublisherSubscriber（发布者/订阅者模式）

     ```python
     import time
     import redis
     # 这个例子生产者和消费者在一个线程

     client = redis.StrictRedis()  # client是生产者
     p = client.pubsub()  # p是消费者，和生产者是不同的连接。
     p.subscribe(&quot;codehole&quot;)  # 客户端发起订阅
     time.sleep(1)  # 模拟网络延时
     print(p.get_message())  # 获取Redis反馈消息通知订阅成功
     client.publish(&quot;codehole&quot;, &quot;java comes&quot;)  # 客户端发布消息
     time.sleep(1)
     print(p.get_message())  # 客户端获取消息
     client.publish(&quot;codehole&quot;, &quot;python comes&quot;)
     time.sleep(1)
     print(p.get_message())
     print(p.get_message())  # 如果当前没有消息，get_message会返回空
     # ----------控制台打印的值
     {&#39;type&#39;: &#39;subscribe&#39;, &#39;pattern&#39;: None, &#39;channel&#39;: b&#39;codehole&#39;, &#39;data&#39;: 1}
     {&#39;type&#39;: &#39;message&#39;, &#39;pattern&#39;: None, &#39;channel&#39;: b&#39;codehole&#39;, &#39;data&#39;: b&#39;java comes&#39;}
     {&#39;type&#39;: &#39;message&#39;, &#39;pattern&#39;: None, &#39;channel&#39;: b&#39;codehole&#39;, &#39;data&#39;: b&#39;python comes&#39;}
     None
     ```

     生产环境，生产者和消费者是分离的。

     生产者：

     ```python
     import redis
     # 生产者

     client = redis.StrictRedis()
     client.publish(&quot;codehole&quot;, &quot;python comes&quot;)
     client.publish(&quot;codehole&quot;, &quot;java comes&quot;)
     client.publish(&quot;codehole&quot;, &quot;golang comes&quot;)
     ```

     消费者：消费者可以启动多个，其他消费者代码和这个一样

     ```python
     import time
     import redis
     # 消费者1号

     client = redis.StrictRedis()
     p = client.pubsub()
     p.subscribe(&quot;codehole&quot;)
     while True:
         msg = p.get_message()  # 非阻塞形式
         if not msg:
             time.sleep(1)  # 休眠阻塞，可能带来1s的延迟（即睡前消息刚到了，而我睡了1s）
             continue
         print(msg)
     # ---------消费者控制台打印值，消费者2号等其他消费者也是一样的。
     {&#39;type&#39;: &#39;subscribe&#39;, &#39;pattern&#39;: None, &#39;channel&#39;: b&#39;codehole&#39;, &#39;data&#39;: 1}
     {&#39;type&#39;: &#39;message&#39;, &#39;pattern&#39;: None, &#39;channel&#39;: b&#39;codehole&#39;, &#39;data&#39;: b&#39;python comes&#39;}
     {&#39;type&#39;: &#39;message&#39;, &#39;pattern&#39;: None, &#39;channel&#39;: b&#39;codehole&#39;, &#39;data&#39;: b&#39;java comes&#39;}
     {&#39;type&#39;: &#39;message&#39;, &#39;pattern&#39;: None, &#39;channel&#39;: b&#39;codehole&#39;, &#39;data&#39;: b&#39;golang comes&#39;}
     ```

     必须先启动消费者（首先要订阅，再轮询获取订阅消息），再执行生产者。

     客户端改进：轮询获取由于sleep，会带来一定的sleep延迟，可以使用类似blpop代替休眠以提高消息处理效率。使用listen阻塞监听消息进行处理，这同blpop原理是一样的。

     ```python
     import redis
     # 消费者3号 使用listen阻塞监听消息进行处理

     client = redis.StrictRedis()
     p = client.pubsub()
     p.subscribe(&quot;codehole&quot;)
     for msg in p.listen():  # 阻塞形式
         print(msg)
     ```

   * 模式订阅

     如果想要订阅多个主题，那就subscribe多个名称。

     ```mysql
     # 同时订阅三个主题，会有三条订阅成功反馈消息
     127.0.0.1:6379&gt; subscribe codehole.image codehole.text codehole.blog
     Reading messages... (press Ctrl-C to quit)
     1) &quot;subscribe&quot;
     2) &quot;codehole.image&quot;
     3) (integer) 1
     1) &quot;subscribe&quot;
     2) &quot;codehole.text&quot;
     3) (integer) 2
     1) &quot;subscribe&quot;
     2) &quot;codehole.blog&quot;
     3) (integer) 3
     ```

     生产者向这三个主题发布消息

     ```mysql
     127.0.0.1:6379&gt; publish codehole.image https://www.google.com/dudo.png
     (integer) 1
     127.0.0.1:6379&gt; publish codehole.text &quot;您好，欢迎订阅我们！&quot;
     (integer) 1
     127.0.0.1:6379&gt; publish codehole.blog &#39;{&quot;content&quot;: hello, everyone&quot;, &quot;title&quot;: &quot;welcome&quot;}&#39;
     (integer) 1
     ```

     很快啊，啪的一下，客户端就会收到消息：

     ```mysql
     1) &quot;message&quot;
     2) &quot;codehole.image&quot;
     3) &quot;https://www.google.com/dudo.png&quot;
     1) &quot;message&quot;
     2) &quot;codehole.text&quot;
     3) &quot;\xe6\x82\xa8\xe5\xa5\xbd\xef\xbc\x8c\xe6\xac\xa2\xe8\xbf\x8e\xe8\xae\xa2\xe9\x98\x85\xe6\x88\x91\xe4\xbb\xac\xef\xbc\x81&quot;
     1) &quot;message&quot;
     2) &quot;codehole.blog&quot;
     3) &quot;{\&quot;content\&quot;: hello, everyone\&quot;, \&quot;title\&quot;: \&quot;welcome\&quot;}&quot;


     ```

     如果要增加一个主题codehole.group，客户端必须跟着增加一个订阅指令才可以接受新开主题的消息推送。为了简化订阅的烦琐，Redis提供了模式订阅功能Pattern Subscribe，这样就可以一次订阅多个主题，即使生产者增加了同模式的主题，消费者无需重新订阅即可接收消息。

     ```mysql
     # --------------消费者消费消息
     127.0.0.1:6379&gt; psubscribe codehole.*
     Reading messages... (press Ctrl-C to quit)
     1) &quot;psubscribe&quot;
     2) &quot;codehole.*&quot;
     3) (integer) 1
     # --------------生产者发布消息
     127.0.0.1:6379&gt; publish codehole.text &quot;this is a msg&quot;
     (integer) 1
     127.0.0.1:6379&gt; publish codehole.grop &quot;ha ha&quot;
     (integer) 1
     # --------------消费者接收到的消息
     1) &quot;pmessage&quot;
     2) &quot;codehole.*&quot;
     3) &quot;codehole.text&quot;
     4) &quot;this is a msg&quot;
     1) &quot;pmessage&quot;
     2) &quot;codehole.*&quot;
     3) &quot;codehole.grop&quot;
     4) &quot;ha ha&quot;
     # 注意了：刚开始用susbscribe codehole.*订阅，消费者接收反馈消息正常，但再用生产者发布消息时，发布不成功。（个人思考：可能时subscribe codehole.*是不支持模式订阅的，它并没有产生消息队列，所以生产者无法找到队列来发布消息，就发布失败了。）
     # 消费者订阅 接收所有消息
     127.0.0.1:6379&gt; psubscribe *
     Reading messages... (press Ctrl-C to quit)
     1) &quot;psubscribe&quot;
     2) &quot;*&quot;
     3) (integer) 1
     # 生产者发布
     127.0.0.1:6379&gt; publish anypattern &quot;听说你能接收所有消息！&quot;
     (integer) 1
     # 消费者接收
     1) &quot;pmessage&quot;
     2) &quot;*&quot;
     3) &quot;anypattern&quot;
     4) &quot;\xe5\x90\xac\xe8\xaf\xb4\xe4\xbd\xa0\xe8\x83\xbd\xe6\x8e\xa5\xe6\x94\xb6\xe6\x89\x80\xe6\x9c\x89\xe6\xb6\x88\xe6\x81\xaf\xef\xbc\x81&quot;
     ```

   * 消费结构

     如前面的python消费者接收到的消息：

     ```
     {&#39;type&#39;: &#39;subscribe&#39;, &#39;pattern&#39;: None, &#39;channel&#39;: b&#39;codehole&#39;, &#39;data&#39;: 1}
     {&#39;type&#39;: &#39;message&#39;, &#39;pattern&#39;: None, &#39;channel&#39;: b&#39;codehole&#39;, &#39;data&#39;: b&#39;python comes&#39;}
     ```

     data：就是消息的内容，一个字符串

     channel：当前订阅的主题名称

     type：消息的类型，如果是普通的消息，类型就是message；如果是控制消息，比如订阅指令的反馈，它的类型就是subscribe；如果是模式订阅的反馈，它的类型就是psubscribe；此外还有取消订阅指令的反馈unsubscribe和punsubscribe。

     pattern：表示当前消息使用哪种模式订阅到的。如果是通过subscribe指令订阅的，那么这个字段就是空。

   * PubSub的缺点

     消费者断连期间，对于生产者发送的消息，它是收不到的。

     如果Redis停机重启，PubSub的消息是不会持久化的，所有的消息会被丢弃。

     正因为这些缺点，在消息队列领域它几乎找不到合适的应用场景，Redis作者因此单独开启了一个项目Disque专门用作多播消息队列。

   * 补充

     Redis5.0新增了Stream数据结构，这个功能给Redis带来了持久化的消息队列，PubSub作为消息队列的功用可以消息了，Disque估计也不会继续发展。

7. **小对象压缩** | 开源节流

   Redis是一个非常耗费内存的数据库，它所有的数据都放在内存。因此需要优化数据结构的内存占用。

   * 32bit VS 64bit

     Redis如果使用32bit进行编译，内部所有数据结构所使用的指针空间占用会少一半。如果你的Redis使用占用内存不超过4GB，可以考虑32bit进行编译。这对小型站点是绰绰有余，如果不足还可以增加实例方式来解决。

   * 小对象压缩存储（ziplist）

     如果Redis内部管理的集合数据结构很小，它会使用紧凑存储形式压缩存储。

     Redis的ziplist是一个紧凑的字节数组结构：

     [(zlbytes，4字节，整个压缩列表占用的字节数)，(zltail，4字节，最后一个entry的偏移量，便于直接定位尾部元素)，(zllen，2字节，entry的数量)，entry，entry，...，entry，(zllen，1字节，魔术整数255用于标记结果)]

     如果它存储hash结构，那么key和value会作为两个entry被相邻存储。

     ```mysql
     127.0.0.1:6379&gt; hset hello a 1
     (integer) 1
     127.0.0.1:6379&gt; Object encoding hello
     &quot;ziplist&quot; # 如果hash里面的数据很多，比如一万，他就会是hashtable结构
     ```

     如果存储zset结构，那么value和score会作为两个entry被相邻存储。数据较少时是ziplist，数据较多时时skiplist。

     inset用于存放元素都是整数切元素个数较少的的set集合。如果整数可以用unit16，那么intset的元素就是16位的数组，如果新加入的整数超过了unit16的表示方位，就是用unit32，超过32就用64。Redis支持set集合从unit16升级到32，再升级到unit64。

     [(encoding，等于value的位宽16/32/64)，(元素的个数)，value，...，value]。

     如果set里面存储的是字符串，那么sadd立即升级为hashtable结构。

     【存储界限】，当集合对象的元素增加，或某个value值过大，小对象存储会升级为标准结构。

     ```
     hash-max-ziplist-entries 512 # hash元素个数超过512必须用标准结构
     hash-max-ziplist-value 64 # hash中任意元素的key或value长度超过64必须用标准结构
     list-max-ziplist-entries 512
     list-max-ziplist-value 64
     zset-max-ziplist-entries 128
     zset-max-ziplist-value 64
     set-max-intset-entries 512
     ```

   * 内存回收机制

     操作系统是以页为单位回收内存的。如果当前Redis内存有10GB，删除了1GB，内存不会有太大变化。因为key是分散在页的，只要页中还有正在使用的key，页就不会被回收。删除了某些key，页中空出的位置可以被其他key占用。（一个形象的例子：电影院的座位，删除key只是人走了，其他人可以继续坐，而flushdb是将座位都移走）

     执行flushdb，会删除所有的key，这时内存会回收。

   * 内存分配算法

     Redis将分配的细节让第三方库实现。目前Redis使用jemalloc(facebook)库管理内存（默认），可使用tcmalloc(google)库。

     **info memory**指令可以查看内存情况

## 三、集群篇

1. **主从同步** | 有备无患

   没有使用Redis的集群的公司，大多都做了主从。主从可以保证主节点（Master）挂掉的时候，运维让从节点（Slave）过来接管，服务就可以继续。否则主节点需要经过数据恢复和重启的过程，这可能很耗时，影响线上业务。

   * CAP原理（现代分布式系统的理论基础）

     * C：Consistent，一致性
     * A：Availability，可用性
     * P：Partition tolerance，分区容忍性。（分布式系统节点往往分布在不同的机器上进行网络隔离开的。如果网络断开，那么称这种网络断开场景为网络分区）

     网络分区发生时，数据的一致性将无法得到保证（可用但无一致），除非牺牲可用性（一致但不可用），即暂停分布式节点服务，不提供修改数据的功能，直到网络状况恢复再继续对外提供服务。CAP原理就是，当网络分区发生时，一致性和可用性两难全。

   * 最终一致

     Redis的主从数据是异步同步的，因此分布式Redis系统不满足一致性，满足可用性，但它保证最终一致性。即从节点会努力追赶主节点，尽力保持和主节点一致。

   * 主从同步与从从同步

     从从同步是Redis后续版本增加的功能，以减轻主节点的同步负担。

     ```
     Master--replicate--&gt;Slave--replicate--&gt;Slave
           --replicate--&gt;Slave--replicate--&gt;Slave
     ```

   * 增量同步

     Redis增量同步的是指令流，主节点会将修改指令记录在本地buffer，然后异步将指令同步到从节点，从节点一遍执行同步的指令流，一边像主节点反馈自己同步到哪了（偏移量）。这个buffer是一个定长的环形数组，如果数组内容满了，就会从头开始覆盖前面的内容。

     问题：如果从节点短时间无法和主节点进行同步，就会造成buffer覆盖的问题。引入快照同步。

   * 快照同步

     快照同步非常耗费资源，它首先需要在主节点进行一次bgsave，将当前内存的数据全部快照到磁盘文件中，然后再将快照文件的内容传送到从节点。从节点接收完毕后，需要清空内存，执行一次全量加载，加载完毕后，通知主节点进行增量同步。（快照同步刚开始，那么buffer里之前指令就不要同步了，从同步开始到结束之间这时候的buffer指令需要同步，也就是说要保证快照同步时间要少于buffer一次性写满的时间）。如果同步时间过长，或者buffer太小，可能导致buffer写满了，同步还没完成，就需要重新快照同步，甚者导致快照同步死循环。因此需要**配置一个合适的复制buffer大小**的参数。

   * 增加从节点

     需要先进行一次快照同步，同步完成后继续进行增量同步。

   * 无盘复制

     主节点进行快照同步时，写入磁盘会很耗时，非SSD磁盘存储时，这很糟糕。特别是当系统正在进行AOF的fsync操作时（强制刷回磁盘），如果发生快照同步，fsync会延迟，影响主节点的服务效率。

     从Redis2.8.18版本开始，Redis支持无盘复制。即不经过磁盘，直接通过套接字将快照内容发送到从节点，主节点一边遍历内存，一边将序列化的内容发送到从节点，从节点先将接收到的内容存储到磁盘文件中，再一次性加载。

   * wait指令，Redis3.0版本以后

     Redis的复制是异步的，wait可以让异步复制变成同步复制，确保系统的强一致性（不严格）。

     ```mysql
     127.0.0.1:6379&gt; set key value
     OK
     127.0.0.1:6379&gt; wait 1 0 # 第一个参数是从节点数量，第二个参数是时间（单位毫秒）。含义：该指令之前的所写操作同步到N个从节点（确保N个从节点的同步没有滞后），最多等待时间t。如果t=0表示无限等待直到N个从节点同步完成。这可能导致永远阻塞，即一致而不可用。
     (integer) 1
     ```

   * 小结

     主从复制是Redis分布式的基础。如果Redis只用作缓存，跟memcache一样，也就不需要从节点备份，挂掉了重启一下就行。如果使用了Redis的持久化功能，必须认真对待主从复制，它是系统数据安全的基础保障。

2. **Sentinel** | 李代桃僵

   sentinel，意为哨兵。它是用来当故障发生时，让系统自动进行主从切换，程序无需重启，无需运维人员手工进行主从切换。可以将Redis Sentinel集群看成是一个zookeeper集群，它是集群高可用的心脏，一般由3到5个节点组成，即使个别节点挂了，集群还可以正常运转。

   Sentinel负责持续监控主从节点的健康，当主节点挂掉时，自动选择一个最优的从节点切换成主节点。

   客户端连接集群时，首先连接Sentinel，通过Sentinel来查询主节点的地址，然后再连接主节点进行数据交互。当主节点发生故障时，客户端重新向Sentinel要地址，Sentinel会将最新的主节点地址告诉客户端。主节点挂了，原先的主从复制断开，客户端和损坏的主节点也断开。一个节点提升为新的主节点，其他从节点开始和新的主节点建立复制关系。当挂了的主节点恢复后，它将会称为新主节点的从节点。

   * 消息丢失

     Redis主从采用异步复制，当主节点挂掉时，从节点可能没有收到全部的同步消息，这部分未同步的消息就丢失了。如果主从延迟特别大，那么丢失的数据就可能会特别多（失去一致性）。Sentinel无法保证消息完全不丢失，但尽量保证消息少丢失。它有两个参数可以限制主从延迟过大（延迟过大那就暂停服务）。

     ```
     min-slaves-to-write 1 # 至少有一个从节点在进行正常复制，否则就停止对外写服务，丧失可用性。
     min-slaves-max-lag 10 # 单位秒，如果10s内没有收到从节点的反馈，视为异常
     ```

   * Sentinel基本用法

     python客户端做法：

     ```python
     from redis.sentinel import Sentinel
     # Sentinel默认端口26379
     sentinel = Sentinel([(&#39;localhost&#39;, 26379)], socket_timeout=0.1)
     sentinel.discover_master(&#39;mymaster&#39;)  # 获取主地址，只有一个
     # 控制台返回 (&#39;127.0.0.1&#39;,6379)
     sentinel.discover_slaves(&#39;mymaster&#39;)  # 获取从地址，可以获取多个
     # 控制台返回 (&#39;127.0.0.1&#39;, 6380)
     --------------------------------------
     # 通过xxx_for方法可以从连接池拿出一个连接来使用，因为从地址有多个，Redis客户端对地址采用轮询方案，也就是RoundRobin轮着来。
     master = sentinel.master_for(&#39;mymaster&#39;, socket_timeout=0.1)
     slave = sentinel.slave_for(&#39;mymaster&#39;, socket_timeout=0.1)
     master.set(&#39;foo&#39;, &#39;bar&#39;)
     slave.get(&#39;foo&#39;)
     # 控制台返回 &#39;bar&#39;
     ```

     当Sentinel进行主从切换时，客户端如何知道地址变更了？redis-py在建立连接是进行了主节点地址变更判断。连接池建立连接时（难道实际场景一个客户端会同时有多个连接？），会去查询主节点地址，然后和内存中的主节点地址进行比对，如果变更了，断开所有连接，使用新地址建立新连接。如果是旧的主节点挂了，那么正在使用的连接都会关闭，然后重连时使用新的地址。如果是Sentinel主动进行主从切换，主节点没有挂掉，且旧主节点还在使用，没有新连接建立，redis.py在处理命令的时候会捕获特殊的异常ReadOnlyError，在这个异常里将所有的旧连接全部关闭，后续指令就会重连。

     主从切换后，所有的修改性指令都会抛出ReadOnlyError异常，如果没有修改性指令，连接不会切换，因为数据不会破坏，所以切不切换无所谓。

3. **Codis** | 分而治之

   大数据高并发场景，单个Redis吃不消（内存大导致rdb文件过大，导致全量同步时间过长，单个Redis只能利用单个CPU核心，单个核心压力大），需要Redis集群方案。

   Codis，A Redis Cluster Solution，是Redis集群方案之一。由前豌豆荚中间件团队开发，项目带头人刘奇又开发出开源分布式数据库TiDB。它使用go语言开发，是一个代理中间件，使用Redis协议对外提供服务。当客户端向Redis发送指令时，Codis负责将指令转发到后面的Redis实例来执行，并将返回结果转回给客户端。

   Codis上挂接的所有Redis实例构成一个Redis集群，集群空间不足时，可以通过动态增加Redis实例实现扩容需求。

   客户端操作Codis与操纵Redis几乎没有区别。

   因为Codis是无状态的，只是一个转发代理中间件，那我们可以启动多个Codis实例，供客户端使用，每个Codis节点都是对等的，这样可以显著增加整体的QPS需求，还有容灾功能。

   * Codis分片原理

     Codis要负责将特定的key转发到特定的Redis实例。Codis默认将所有的key划分为1024个槽位（slot）（这个可以配置），它首先对客户端发过来的key进行crc32运算计算hash值，再将hash后的整数对1024求余，这个余数就是对应的key槽位。每个槽位会唯一映射到一个Redis实例。Codis会在内存中维护槽位和Redis实例的映射关系。

     ```
     hash = crc32(command.key)
     slot_index = hash % 1024
     redis = slots[slot_index].redis
     redis.do(command)
     ```

   * 不同的Codis实例之间槽位关系如何同步

     Codis需要一个分布式配置存储数据库专门用来持久化槽位关系。Codis支持zookper，etcd等。

     Codis Dashboard --修改槽位--&gt; zookeeper --同步槽位--&gt;Codis Proxy（多个）

   * 扩容

     增加一个Redis实例，Codis需要调整槽位映射，同时部分槽位对应的所有key都要迁移到新的Redis实例。

     Codis增加了SLOTSSCAN指令，可以遍历指定slot下所有的key，Codis通过这个命令扫描出待迁移槽位的所有key，然后挨个迁移每个key到新的Redis节点。

     迁移过程中，Codis会接收新的请求打在当前迁移的槽位上，并且接收到位于正在迁移槽位中的key后，会立即强制对当前的单个key进行迁移，迁移完成后，再将请求转发到新的Redis实例。

   * 自动均衡

     Redis新增实例，Codis提供了自动均衡功能。自动均衡会在系统比较空闲的时候观察每个Redis实例对应的slot数量，如果不平衡，就会自动进行迁移。

   * Codis的代价

     不支持事务（Codis中的key分散，事务只能在单个Redis实例中完成）

     不支持rename操作（参数有两个key，如果新key在另一个实例中存在，但是这个实例没有，造成key重复）

     单个key对应的value不宜过大（集群迁移最小单位是key，如果过大容易造成迁移卡顿，官方建议单个集合结构的总字节容量不要超过1MB），可以考虑分桶存储，在业务上作折中。

     增加了网络开销

     增加了zookper运维的代价

   * Codis的优点

     比官方Cluster方案简单

   * mget指令操作过程

     mget指令用于批量获取多个key的值，这些key可能会分步在多个Redis实例中。Codis的策略是将key按照所分配的实例打算分组，然后依次对每个实例调用mget方法，最后将结果汇总为一个，再返回给客户端。

4. **Cluster** | 众志成城

   Redis Cluster是Redis作者自己提供的Redis集群化方案，Redis Cluster是去中心化的，每个节点负责整个集群的一部分数据，这个数据多少可能不一样。节点之间通过一种特殊的二进制协议交互集群消息。

   Redis Cluster将所有数据划分为16384个槽位，每个节点负责其中一部分槽位。槽位信息存储于每个节点中。

   客户端需要缓存槽位相关信息，这样可以直接定位某个具体的key所在节点，同时客户端和服务器存储槽位信息可能出现不一致的情况，需要纠正机制实现槽位信息的校验调整。

   另外，Redis Cluster会将集群配置信息持久化到配置文件，需确保配置文件是可写的，而且尽可能不依靠人工修改。

   * 槽位定位算法

     Redis Cluster默认对key使用crc16算法进行hash，得到一个整数，再对16384求余得到具体的槽位。Redis Cluster允许用户强制把某个key挂在特定槽位上。通过在key字符串里面嵌入tag标记，就可以强制key所挂的槽位等于tag所在的槽位。

   * 跳转

     ```mysql
     GET x # 当客户端向一个错误的节点发出指令后
     -MOVED 3999 127.0.0.1:6381 # 节点发现指令的key不归自己管，会发送一个跳转指令。3999是key对应的槽位编号，后面是目标节点地址。客户端收到MOVED指令后，要立即纠正本地的槽位映射表，后续所有的key将使用新的槽位映射表。
     ```

   * 迁移

     Redis提供了工具redis-trib让运维人员手动调整槽位的分配情况，它使用Ruby语言开发，通过组合各种原生的Redis Cluster指令来实现。

     Redis迁移的单位是槽，Redis是一个槽一个槽进行迁移的，当一个槽正在迁移时，这个槽就处于中间过渡状态，这时，槽在源节点的状态为migrating，在目标节点的状态是importing，表示数据正在从源节点流向目标节点。

     redis-trib会在源节点和目标节点设置好中间过渡状态，然后一次性获取源节点槽位的所有key列表（keysinslot指令，可以部分获取），再挨个key进行迁移。源节点对当前的key执行dump指令得到序列化内容，然后向目标节点发送restore指令携带序列化的内容作为参数，目标节点再进行反序列化就可以将内容回复到目标节点的内存中，然后返回源节点OK，源节点收到后再删掉已迁移过去的key，这样完成了单个key迁移全过程。

     这里的迁移过程是同步的，在目标节点执行restore指令到源节点删除key之间，源节点的主线程会阻塞，直到key被成功删除。

     如果迁移过程出现网络故障，整个槽的迁移只进行了一半，这时，两个节点仍处于中间过渡状态，待下次迁移工具重新连上时，会提示用户继续进行迁移。

     迁移过程如果key内容很大，因为migrate指令是阻塞指令，会同时导致源节点和目标节点卡顿，影响集群的稳定性。所以集群环境，要避免大key。

     迁移过程中，客户端的访问流程：

     client--get key--&gt;源节点（如果存在key，就处理，否则返回客户端重定向指令。这时要么key不存在，要么在新节点）--[-ASK targetNode Addr]--&gt;client--ASKING指令(不带参数)--&gt;目标节点--OK/ERR--&gt;client（如果是OK，就继续访问目标节点）--get key--&gt;目标节点。

     执行ASKING指令的必要性：

     在迁移未完成前，如果直接从目标节点get key，目标节点会返回一个重定向指令告诉client去源节点去执行，形成重定向循环。这个ASKING指令就是问目标节点，我client的下一条指令不能不理，而要当成自己的槽位来处理。迁移会影响服务效率，正常情况，客户端访问集群一个ttl就能完成，而迁移情况需要3个ttl才能搞定（请求源，ask目标，请求目标）。

   * 容错

     Redis Cluster可以为每个主节点设置若干个从节点，当主节点发生故障时，集群会自动将其中某个从节点提升为主节点。Redis提供了一个参数cluster-require-full-coverage可以允许部分节点发生故障，其他节点还可以继续提供对外访问。

   * 网络抖动（突然之间部分连接不可访问，然后很快又恢复正常）

     Redis Cluster提供了一种选项cluster-node-timeout，表示当某个节点持续timeout时间失联时，才可以认定该节点出现故障，需要进行主从切换。如果没有这选项，网络抖动会导致主从频繁切换（数据的重新复制）。

     cluster-slave-validity-factor作为倍乘系数放大这个超时时间来宽松容错的紧急程度。值为0时，主从切换不会抗拒网络抖动，大于1时，就成了主从切换松弛系数。

   * 可能下线（PFail）和确定下线（Fail）

     如果一个节点下线，另一个节点发现某个节点失联了（PFail，possible fail），它会将失联节点的消息向整个集群广播，如果收到这条消息的节点数量（PFail Count）占集群的大多数，就可以标记该失联节点为确定下线状态（Fail），然后向整个集群广播，强迫其他节点标记下线节点，并对失联节点进行主从切换。

   * Cluster基本用法

     ```python
     from rediscluster import RedisCluster
     # 可以只用一个节点地址，其他地址可以自动通过这个节点来发现。提供多个节点地址，安全性更好。
     # 因为如果这个节点挂了，如果还有其他节点的话，可以继续访问集群，否则需要更换节点
     startup_nodes = [{&quot;host&quot;: &quot;127.0.0.1&quot;, &quot;port&quot;: &quot;6379&quot;}]
     # decode_responses表示是否将返回的byte数组转换成Unicode
     rc = RedisCluster(startup_nodes=startup_nodes, decode_responses=True)
     rc.set(&quot;foo&quot;, &quot;bar&quot;)
     print(rc.get(&quot;foo&quot;))
     ```

     Cluster不支持事务；Cluster的mget方法比Redis要慢很多，被拆分成了多个get指令；Cluster的rename方法不再是原子的，它需要将数据从源节点转移到目标节点。

   * 槽位迁移感知

     两个错误指令：

     MOVED指令：客户端发送到了错误的节点，节点回复客户端通知客户端去目标节点去访问，这时客户端会刷新自己的槽位关系表，然后重试指令。

     ASKING指令：指这个-ASK targetNode Addr，这个不会导致客户端的槽位更新。

     【重试2次】

     比如一条指令发送到错误节点，这个节点返回一个MOVED错误告知你去重试另外一个节点，恰好运维人员对另外一个节点的槽位进行迁移操作，于是给客户端回复了ASKING指令告知客户端去目标节点去重试指令。

     【重试多次】

     实际上是会存在的，因此客户端的源码在执行指令时会有一个循环，设置一个最大重试次数，如果超过了最大重试次数，客户端直接向业务层抛出异常。

   * 集群变更感知

     当服务器节点变更时，客户端得到通知的方式：

     * 目标节点挂掉了，客户端会抛出高一个ConnectionError，紧接着会随机挑一个节点重试，试错的节点通过MOVED指令重定向到正确节点上。
     * 运维手动修改了集群信息，将主节点切换到其他节点，将旧的主节点移除出集群。这时打在旧的主节点上的指令会收到ClusterDown的错误，告知当前节点所在集群不可用。这时客户端就会关闭所有的连接，清空槽位映射关系表，然后向上抛错。等到下一条指令过来，会重新尝试初始化节点信息。

## 四、拓展篇

1. **Stream** | 耳听八方，Redis5.0，借鉴了kafka，支持多播的可持久化消息队列。

   它是一个消息链表（即Stream，每个Stream有唯一名称，就是Redis的key），将所有加入的消息都串起来。每个消息都有一个唯一的ID和对应的内容。

   【消息ID和内容】

   消息ID的形式是timestampInMillis-sequence，如1527846880572-5表示当前消息在这个时间点产生，并且是这个时间点的第5条消息。这个消息ID可以由服务器自动生产，也可由客户端指定，但是形式必须是“整数-整数”，且后面的消息ID要大于前面的。

   消息的内容就是键值对。

   【消费组】

   一个Stream可以挂多个（意味着支持多播）消费组（Consumer Group，一组消费者），每个消费组有个游标last_delivered_id在Stream上往前移动，表示当前消费组消费到哪了。消费组有一个唯一的名称，它不会自动创建，需要单独的指令xgroup create创建，需要指定从Stream的某个消息ID开始消费，这个ID用来初始化last_delivered_id变量。

   消费组之间是独立的，互不影响。

   【消费者】

   一个消费组可以挂多个消费者（Consumer，具体的客户端），消费者之间是竞争关系，即组内任意一个消费者读取了消息都会使消费组的游标往前移动。每个消费者有组内唯一名称。

   消费者内部有一个状态变量pending_ids[]（官方称为PEL，Pending Entries List，用来确保客户端至少消费了消息一次，而不会在网络传输中途丢失而没被处理），记录了当前已经被客户端读取，但是还没有ack的消息（这种消息应该也会导致消费组的游标前移）。如果客户端没有ack，那么这个变量里的消息ID会增多，如果消息被ack，它就会减少。

   * 增删改查

     * xadd：向Stream追加消息。（首次追加消息时，会自动创建Stream数据结构）
     * xdel：从Stream中删除消息，仅仅是设置标志位，不影响消息总长度。
     * xrange：获取Stream中的消息列表，会自动过滤已经删除的消息。
     * xlen：获取Stream消息长度。
     * del：删除整个Stream消息列表中的所有消息。

     ```mysql
     # * 表示服务器自动生成ID，后面跟着key，value
     127.0.0.1:6379&gt; xadd codehole * name laoqian age 30
     &quot;1618714326250-0&quot; # 生成的消息ID
     127.0.0.1:6379&gt; xadd codehole * name xiaoyu age 29
     &quot;1618714347362-0&quot;
     127.0.0.1:6379&gt; xadd codehole * name xiaoqian age 1
     &quot;1618714367519-0&quot;
     127.0.0.1:6379&gt; xlen codehole
     (integer) 3
     127.0.0.1:6379&gt; xrange codehole - + # -表示最小值，+表示最大值
     1) 1) &quot;1618714326250-0&quot;
        2) 1) &quot;name&quot;
           2) &quot;laoqian&quot;
           3) &quot;age&quot;
           4) &quot;30&quot;
     2) 1) &quot;1618714347362-0&quot;
        2) 1) &quot;name&quot;
           2) &quot;xiaoyu&quot;
           3) &quot;age&quot;
           4) &quot;29&quot;
     3) 1) &quot;1618714367519-0&quot;
        2) 1) &quot;name&quot;
           2) &quot;xiaoqian&quot;
           3) &quot;age&quot;
           4) &quot;1&quot;
     127.0.0.1:6379&gt; xrange codehole 1618714347362-0 + # 指定最小消息ID的列表
     1) 1) &quot;1618714347362-0&quot;
        2) 1) &quot;name&quot;
           2) &quot;xiaoyu&quot;
           3) &quot;age&quot;
           4) &quot;29&quot;
     2) 1) &quot;1618714367519-0&quot;
        2) 1) &quot;name&quot;
           2) &quot;xiaoqian&quot;
           3) &quot;age&quot;
           4) &quot;1&quot;
     127.0.0.1:6379&gt; xrange codehole - 1618714347362-0 # 指定最大消息ID的列表
     1) 1) &quot;1618714326250-0&quot;
        2) 1) &quot;name&quot;
           2) &quot;laoqian&quot;
           3) &quot;age&quot;
           4) &quot;30&quot;
     2) 1) &quot;1618714347362-0&quot;
        2) 1) &quot;name&quot;
           2) &quot;xiaoyu&quot;
           3) &quot;age&quot;
           4) &quot;29&quot;
     127.0.0.1:6379&gt; xdel codehole 1618714326250-0
     (integer) 1 # 这里5.0.7版本删除后，xlen受影响，作者当时版本可能xlen不受影响。
     127.0.0.1:6379&gt; xlen codehole
     (integer) 2 
     127.0.0.1:6379&gt; xrange codehole - +
     1) 1) &quot;1618714347362-0&quot;
        2) 1) &quot;name&quot;
           2) &quot;xiaoyu&quot;
           3) &quot;age&quot;
           4) &quot;29&quot;
     2) 1) &quot;1618714367519-0&quot;
        2) 1) &quot;name&quot;
           2) &quot;xiaoqian&quot;
           3) &quot;age&quot;
           4) &quot;1&quot;
     127.0.0.1:6379&gt; del codehole # 删除整个Stream
     (integer) 1
     127.0.0.1:6379&gt; xlen codehole
     (integer) 0
     ```

   * 独立消费

     不定义消费组，使用xread，可以将Stream当成普通的消息队列来使用。当Stream没有新消息时，可以阻塞等待。客户端如果想要使用xread进行顺序消费，必须保留返回的消息ID，下次继续调用xread，将上次返回的最后一个消息ID作为参数传递进去，就可以继续消费后续的消息。

     block 0表示永远阻塞；block 1000表示阻塞1s，如果1s内没有任何消息到来，就返回nil。

     ```mysql
     # 从Stream头部读取两条消息（从0-0开始到当下时刻范围）
     127.0.0.1:6379&gt; xread count 2 streams codehole 0-0
     1) 1) &quot;codehole&quot;
        2) 1) 1) &quot;1618727680422-0&quot;
              2) 1) &quot;name&quot;
                 2) &quot;name1&quot;
                 3) &quot;value&quot;
                 4) &quot;value1&quot;
           2) 1) &quot;1618727688849-0&quot;
              2) 1) &quot;name&quot;
                 2) &quot;name2&quot;
                 3) &quot;value&quot;
                 4) &quot;value2&quot;
     # 从Stream尾部读取2条消息，这里不会返回任何消息（从当下时刻到未来时刻）
     127.0.0.1:6379&gt; xread count 2 streams codehole $
     (nil)
     # 从尾部阻塞等待消息到来，下面的指令会堵住，直到新消息到来
     127.0.0.1:6379&gt; xread block 0 count 1 streams codehole $
     # 另外一个窗口添加消息后才返回的
     1) 1) &quot;codehole&quot;
        2) 1) 1) &quot;1618727968315-0&quot;
              2) 1) &quot;name&quot;
                 2) &quot;name4&quot;
                 3) &quot;value&quot;
                 4) &quot;value4&quot;
     (97.71s) # 还会显示等待了的时间
     # 另起窗口添加消息
     127.0.0.1:6379&gt; xadd codehole * name name4 value value4
     &quot;1618727968315-0&quot;
     ```

   * 创建消费组

     xgroup create key consumergroup start（起始消息ID参数用来初始化last_delivered_id变量）

     ```mysql
     127.0.0.1:6379&gt; xgroup create codehole cg1 0-0 # 表示从头部开始消费
     OK
     127.0.0.1:6379&gt; xgroup create codehole cg2 $ # 表示从尾部开始消费，只接受新消息，当前Stream消息会全部忽略
     OK
     127.0.0.1:6379&gt; xinfo stream codehole # 获取Stream信息
      1) &quot;length&quot;
      2) (integer) 4
      3) &quot;radix-tree-keys&quot;
      4) (integer) 1
      5) &quot;radix-tree-nodes&quot;
      6) (integer) 2
      7) &quot;groups&quot;
      8) (integer) 2 # 2个消费组
      9) &quot;last-generated-id&quot;
     10) &quot;1618727968315-0&quot;
     11) &quot;first-entry&quot; # 第一个消息
     12) 1) &quot;1618727680422-0&quot;
         2) 1) &quot;name&quot;
            2) &quot;name1&quot;
            3) &quot;value&quot;
            4) &quot;value1&quot;
     13) &quot;last-entry&quot; # 最后一个消息
     14) 1) &quot;1618727968315-0&quot;
         2) 1) &quot;name&quot;
            2) &quot;name4&quot;
            3) &quot;value&quot;
            4) &quot;value4&quot;
     127.0.0.1:6379&gt; xinfo groups codehole # 获取Stream消费组信息
     1) 1) &quot;name&quot;
        2) &quot;cg1&quot; # 消费组cg1
        3) &quot;consumers&quot;
        4) (integer) 0 # 该消费组还没有消费者
        5) &quot;pending&quot;
        6) (integer) 0 # 该消费组没有正在处理的消息
        7) &quot;last-delivered-id&quot;
        8) &quot;0-0&quot;
     2) 1) &quot;name&quot;
        2) &quot;cg2&quot;
        3) &quot;consumers&quot;
        4) (integer) 0
        5) &quot;pending&quot;
        6) (integer) 0
        7) &quot;last-delivered-id&quot;
        8) &quot;1618727968315-0&quot;

     ```

   * 消费

     使用xreadgroup指令进行消费组的组内消费。可以阻塞读。

     xreadgroup GROUP cgname(组名) cname(消费者名) count n(读多少个消息) streams key id(起始id)。

     ```mysql
     # &gt; 号表示从当前消费组的last_delivered_id后面开始读，每当消费者读取一条消息，last_delivered_id变量就会前进
     127.0.0.1:6379&gt; xreadgroup GROUP cg1 c1 count1 streams codehole &gt;
     (error) ERR syntax error
     127.0.0.1:6379&gt; xreadgroup GROUP cg1 c1 count 1 streams codehole &gt;
     1) 1) &quot;codehole&quot;
        2) 1) 1) &quot;1618727680422-0&quot;
              2) 1) &quot;name&quot;
                 2) &quot;name1&quot;
                 3) &quot;value&quot;
                 4) &quot;value1&quot;
     127.0.0.1:6379&gt; xreadgroup GROUP cg1 c1 count 1 streams codehole &gt;
     1) 1) &quot;codehole&quot;
        2) 1) 1) &quot;1618727688849-0&quot;
              2) 1) &quot;name&quot;
                 2) &quot;name2&quot;
                 3) &quot;value&quot;
                 4) &quot;value2&quot;
     127.0.0.1:6379&gt; xreadgroup GROUP cg1 c1 count 2 streams codehole &gt;
     1) 1) &quot;codehole&quot;
        2) 1) 1) &quot;1618727695696-0&quot;
              2) 1) &quot;name&quot;
                 2) &quot;name3&quot;
                 3) &quot;value&quot;
                 4) &quot;value3&quot;
           2) 1) &quot;1618727968315-0&quot;
              2) 1) &quot;name&quot;
                 2) &quot;name4&quot;
                 3) &quot;value&quot;
                 4) &quot;value4&quot;
     127.0.0.1:6379&gt; xreadgroup GROUP cg1 c1 count 1 streams codehole &gt; # 再继续读没有了
     (nil)
     127.0.0.1:6379&gt; xreadgroup GROUP cg1 c1 block 0 count 1 streams codehole &gt; # 阻塞读
     # 另一窗口
     127.0.0.1:6379&gt; xadd codehole * name name5 value value5
     &quot;1618729918396-0&quot;
     # 回到当前窗口
     1) 1) &quot;codehole&quot;
        2) 1) 1) &quot;1618729918396-0&quot;
              2) 1) &quot;name&quot;
                 2) &quot;name5&quot;
                 3) &quot;value&quot;
                 4) &quot;value5&quot;
     (22.66s)
     # 观察消费组信息
     127.0.0.1:6379&gt; xinfo groups codehole
     1) 1) &quot;name&quot;
        2) &quot;cg1&quot;
        3) &quot;consumers&quot;
        4) (integer) 1 # 消费组cg1有一个消费者
        5) &quot;pending&quot;
        6) (integer) 5 # 有5条正在处理的信息还没有ack
        7) &quot;last-delivered-id&quot;
        8) &quot;1618729918396-0&quot;
     2) 1) &quot;name&quot;
        2) &quot;cg2&quot;
        3) &quot;consumers&quot;
        4) (integer) 0 # 消费组cg2没有任何变化，因为没有操纵cg2
        5) &quot;pending&quot;
        6) (integer) 0
        7) &quot;last-delivered-id&quot;
        8) &quot;1618727968315-0&quot;
     # 如果一个消费组有多个消费者，通过xinfo consumers观察每个消费者的状态
     127.0.0.1:6379&gt; xinfo consumers codehole cg1
     1) 1) &quot;name&quot;
        2) &quot;c1&quot;
        3) &quot;pending&quot;
        4) (integer) 5 # 共5条
        5) &quot;idle&quot;
        6) (integer) 460271 # 空闲了多长时间ms没有读取消息了
     # ack一条消息   
     127.0.0.1:6379&gt; xack codehole cg1 1618727680422-0
     (integer) 1
     127.0.0.1:6379&gt; xinfo consumers codehole cg1
     1) 1) &quot;name&quot;
        2) &quot;c1&quot;
        3) &quot;pending&quot;
        4) (integer) 4 # 变成了4
        5) &quot;idle&quot;
        6) (integer) 704800
     # ack所有消息
     127.0.0.1:6379&gt; xack codehole cg1 1618727688849-0 1618727695696-0 1618727968315-0 1618729918396-0
     (integer) 4
     127.0.0.1:6379&gt; xinfo consumers codehole cg1
     1) 1) &quot;name&quot;
        2) &quot;c1&quot;
        3) &quot;pending&quot;
        4) (integer) 0 # pel空了
        5) &quot;idle&quot;
        6) (integer) 764138
     ```

   * Stream消息太多怎么办

     Redis提供了一个定长长度参数maxlen，超过这个长度就将老的消息删除，确保链表不超过指定长度。

     ```mysql
     127.0.0.1:6379&gt; xadd codehole maxlen 3 * name name6 value value6
     &quot;1618731082166-0&quot;
     127.0.0.1:6379&gt; xlen codehole
     (integer) 3
     127.0.0.1:6379&gt; xrange codehole - +
     1) 1) &quot;1618727968315-0&quot;
        2) 1) &quot;name&quot;
           2) &quot;name4&quot;
           3) &quot;value&quot;
           4) &quot;value4&quot;
     2) 1) &quot;1618729918396-0&quot;
        2) 1) &quot;name&quot;
           2) &quot;name5&quot;
           3) &quot;value&quot;
           4) &quot;value5&quot;
     3) 1) &quot;1618731082166-0&quot;
        2) 1) &quot;name&quot;
           2) &quot;name6&quot;
           3) &quot;value&quot;
           4) &quot;value6&quot;
     ```

   * 消息如果忘记ack会怎样

     会导致PEL列表不断增长。

   * PEL如何避免消息丢失

     当客户端读取Stream消息时，在Redis服务器将消息回复给客户端的过程中，如果客户端断开连接，那么等客户端重新连上之后，可以再次收到PEL中的消息ID列表。此时xreadgroup的起始消息ID必须是任意有效的消息ID，一般参数为0-0，表示读取所有的PEL消息以及自last_delivered_id之后的新消息。

   * Stream的高可用性，建立在主从复制上，即在Sentinel和Cluster集群环境，Stream是可以支持高可用的。但也可能丢失极小部分数据。

   * 分区Partition

     Redis服务器没有原生支持分区能力，如需使用分区，需要分配多个Stream，然后在客户端使用一定的策略来生产消息到不同的Stream。

   * 小结

     Stream消费模型借鉴了Kafka的消息分组的概念，弥补了Redis PubSub不能持久化消息的缺陷。但它又不同于Kafka，Kafka的消息可以分区，而Stream不行，非要分区，得在客户端做。

2. **Info指令** | 无所不知，诊断问题

   Info指令显示的信息很多，分为9大块。info可一次性获取所有信息，也可以按块获取。

   1. Server：服务器运行的环境参数

   2. Clients：客户端相关信息

      Redis连接了多少客户端。通过观察其数量可以确定是否有意料之外的连接，如果发现不对劲，可以使用client list指令列出所有客户端链接地址来确定源头。

      ```mysql
      wuyoupeng@wuyoupeng:~$ redis-cli info clients
      # Clients
      connected_clients:2 # 这个就是正在连接的客户端数量
      client_recent_max_input_buffer:2
      client_recent_max_output_buffer:0
      blocked_clients:0
      ```



   3. Memory：服务器运行内存统计数据

      ```mysql
      wuyoupeng@wuyoupeng:~$ redis-cli info memory |grep used |grep human
      used_memory_human:859.35K # 内存分配(jemalloc)从操作系统分配的内存总量
      used_memory_rss_human:7.97M # 操作系统看到的内存占用，top命令看到的内存
      used_memory_peak_human:860.22K # Redis内存消耗的峰值
      used_memory_lua_human:41.00K # lua脚本引擎占用的内存大小
      used_memory_scripts_human:0B
      # 如果单个Redis内存过大，业务上没有太多压缩的空间，应考虑集群化了。
      ```



   4. Persistence：持久化信息

   5. Stats：通用统计数据

      Redis每秒执行多少次指令，如果ops过高，通过monitor指令快速观察哪些key被访问比较频繁

      ```mysql
      # 注意redis-cli控制台下，不能使用|grep ops，要在Linux下使用
      wuyoupeng@wuyoupeng:~$ redis-cli info stats |grep ops
      instantaneous_ops_per_sec:0
      wuyoupeng@wuyoupeng:~$ redis-cli monitor
      OK # monitor指令会瞬间吐出巨量的指令文本，一般执行monitor立即使用ctrl+c中断输出。我这里没有client.
      ^C
      ```

      因超出最大连接数限制而被拒绝的客户端连接次数

      ```mysql
      wuyoupeng@wuyoupeng:~$ redis-cli info stats |grep reject
      rejected_connections:0 # 如果这个值很大，需要调整maxclients
      ```

      主从半同步复制失败次数，根据这个调整是否需要扩大积压缓冲区

      ```mysql
      wuyoupeng@wuyoupeng:~$ redis-cli info stats |grep sync
      sync_full:0
      sync_partial_ok:0
      sync_partial_err:0 # 半同步失败次数
      ```

   6. Replication：主从复制相关信息

      ```mysql
      wuyoupeng@wuyoupeng:~$ redis-cli info replication |grep backlog
      repl_backlog_active:0
      repl_backlog_size:1048576 # 积压缓冲区大小，这个缓冲区就是主从同步增量同步的buffer。
      repl_backlog_first_byte_offset:0
      repl_backlog_histlen:0
      # 如果有多个从节点复制，积压缓冲区是共享的。如果实例的修改指令请求很频繁，那就把积压缓冲区调大一些，几十个MB大小就可以；如果很小，那就设置为几MB大小。
      ```

   7. CPU：CPU使用情况

   8. Cluster：集群信息

   9. KeySpace：键值对统计数量信息

3. **再谈分布式锁** | 拾遗补漏

   分布式锁在集群环境下出现的问题：在Sentinel集群中，client在主节点中申请成功了一把锁，但这把锁还没有同步到从节点，主节点挂了，从节点变成主节点，新的主节点还没有这个锁，当另一个client请求加锁时，立即批准了，由此产生锁失效的问题。

   * Redlock算法，Antirez发明的，很多开源库对它做了封装，如redlock-py，其作者是Paul Decoursey。github id optimuspaul

     ```python
     import redlock
     addrs = [{&quot;host&quot;: &quot;localhost&quot;, &quot;port&quot;: &quot;6379&quot;, &quot;db&quot;: 0},
              {&quot;host&quot;: &quot;localhost&quot;, &quot;port&quot;: &quot;6479&quot;, &quot;db&quot;: 0},
              {&quot;host&quot;: &quot;localhost&quot;, &quot;port&quot;: &quot;6579&quot;, &quot;db&quot;: 0}]
     # RedLock采用“大多数机制”
     dlm = redlock.RedLock(addrs)
     # 加锁时，它会向过半节点发送set(key, value, nx=True, ex=xxx)指令
     # 只要过半节点set成功，就认为加锁成功。
     success = dlm.lock(&quot;user-lck-laoqian&quot;, 5000)
     if success:
         print(&quot;lock success&quot;)
         # 释放锁时，需要向所有节点发送del指令。
         dlm.unlock(&quot;user-lck-laoqian&quot;)
     else:
         print(&quot;ock failed&quot;)
     # Redlock算法还需考虑出错重试、时钟漂移等问题。
     ```

   * 使用场景

     在乎高可用性，即使挂了一台Redis也完全不受影响。代价：需要更多的Redis实例，性能也下降，代码上引入额外的库，运维需要特殊对待等。

4. **过期策略** | 朝生暮死

   Redis所有的数据结构都可以设置过期时间。问题：同一时间太多的key过期，以至于忙不过来？Redis是单线程的，收割时间也会占用线程的处理时间，如果收割操作频繁，会不会导致线上读写指令出现卡顿？

   * 过期的key集合

     Redis会将每个设置了过期时间的key放入一个独立的字典中，以后会定时遍历这个字典来删除到期的key。除了定时遍历，还会使用**惰性策略**：在客户端访问这个key的时候，Redis对key的过期时间检查，如果过期了立即删除。定时遍历是集中处理，惰性策略是零散处理。

   * 定时扫描策略

     Redis默认每秒进行10次（即100ms一次）过期扫描，扫描采用一种简单贪心策略，而不是全部遍历：

     （1）从过期字典中随机选20个key。

     （2）删除这20个key中已经过期的key。

     （3）如果过期的key的比例超过1/4，那就重复步骤（1）

     为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法增加了扫描时间的上限，默认为25ms。

     ```mysql
     # 如果大批量的key过期时间是在同一时刻，导致Redis扫描持续到阈值时间后，而客户端请求正好此时过来了，那么业务端会出现很多异常，并且Redis还无法从showlog中看到慢查询记录（指逻辑处理过程慢），因此开发人员要注意过期时间的设置
     # 在目标过期时间上增加一天的随机时间
     redis.expire_at(key, random.randint(86400) + expire_ts)
     ```

   * 从节点的过期策略

     从节点不会进行过期扫描，从节点对过期的处理是被动的。主节点在key到期时，会在AOF文件里增加一条del指令，同步到所有的从节点，从节点执行这条del命令来删除过期的key。

     由于指令同步是异步进行的，有可能导致主从数据不一致。

5. **LRU** | 优胜劣汰

   生产环境一般不允许Redis 出现交换行为（当Redis内存超出物理内存限制时，内存数据开始和磁盘产生频繁的交换swap，导致性能急剧下降）。为了限制最大使用内存，Redis提供了配置参数maxmemory来限制内存超出期望大小。

   当实际内存超出maxmemory，Redis提供了几种策略（maxmemory-policy）让用户自己决定该如何腾出空间以继续提供读写服务。

   1. noeviction：默认策略。不会继续服务写请求（del请求可以继续服务），读请求可以继续进行。能保证数据不丢失，但线上业务不能继续进行。
   2. volatile-lru：没有设置过去时间的key不会淘汰，尝试淘汰设置了过期时间的key，最少使用的key优先被淘汰。能保证需要持久化的数据不会突然丢失。
   3. volatile-ttl：和2类似，不过淘汰策略是比较key的剩余寿命ttl的值，ttl越小优先被淘汰。（快要死的先淘汰）
   4. volatile-random：和2类似，不过淘汰策略是淘汰过期key集合中随机的key。
   5. allkeys-lru：区别2，不过淘汰的是全体key集合。
   6. allkeys-random：类似5，不过淘汰的key是随机的。

   volatile-xxx只针对带过期时间的key进行淘汰（适合使用Redis的持久化功能，这样可以保留没有设置过期时间的key，它们是永久的key，不会被LRU算法淘汰），allkeys-xxx会对所有key进行淘汰（适合只拿Redis做缓存，客户端写缓存时不必携带过期时间）。

   * LRU算法

     ```python
     from collections import OrderedDict


     # 使用OrderedDict（双向链表+字典）实现简单的LRU


     class LRUDICT(OrderedDict):

         def __init__(self, capacity):
             self.capacity = capacity
             self.items = OrderedDict()

         def __setitem__(self, key, value):
             old_value = self.items.get(key)
             if old_value is not None:  # key有对应的值
                 self.items.pop(key)  # 删除旧的值
                 self.items[key] = value  # 加入新的值
             elif len(self.items) &lt; self.capacity:  # key没有value，且容量够
                 self.items[key] = value
             else:  # key没有value，容量不够
                 # Pairs are returned in LIFO order if last is true or FIFO order if false.
                 # 这里应该是false，原作者这里是True
                 self.items.popitem(last=False)  # 先进先出
                 self.items[key] = value  # 加入

         def __getitem__(self, key):
             value = self.items.get(key)
             if value is not None:  # 此目的是为了将刚访问的key放到后面，实现了最近访问的尽量不删除。
                 self.items.pop(key)
                 self.items[key] = value
             return value

         def __repr__(self):
             return repr(self.items)


     d = LRUDICT(10)  # 初始化容量为10
     for i in range(15):
         d[i] = i  # setitem(i, i)
     print(d)  # 结果是[(5,5)...(14,14)]
     ```

   * 近似LRU算法

     LRU算法需要消耗大量的额外内存。近似LRU算法就是在现有数据结构基础上使用随机采样法淘汰元素，能达到和LRU算法非常近似的效果。

     为了实现近似LRU算法，Redis给每个key增加了一个额外的小字段，长度是24个bit，也就是最后一次被访问的时间戳。

     处理key过期方式有集中处理和懒惰处理，LRU处理方式只有懒惰处理。当Redis执行写操作时，若内存超出maxmemory，就会执行一次LRU淘汰算法。算法内容：随机采出5个（默认，可以手动设置）key，然后淘汰最旧的key，如果淘汰后内存还是超出maxmemory，那就继续随机采样淘汰，直至内存低于maxmemory。

     采样的总体分allkeys和设置了过期时间的key（由maxmemory-policy设置allkeys还是volatile），采样多少通过maxmemory_samples设置（默认为5）。

     Redis3.0增加了淘汰池，进一步提升了近似LRU算法效果。淘汰池是一个数组，大小是maxmemory-samples，在一次淘汰中，新的随机得出的key列表会和淘汰池中的key列表进行融合，淘汰掉最旧的一个key之后，保留剩余较旧的key列表放入淘汰池中留待下一个循环。

6. **懒惰删除** | 平波缓进

   Redis是单线程，但Redis内部还有几个异步线程专门用来处理一些耗时的操作。

   * Redis为什么使用懒惰删除

     del key，如果key很大，会导致单线程卡顿。4.0版本引入unlink指令，能对删除操作进行懒处理，丢给后台线程来异步回收内存。unlink key后，其他指令不能访问key，内存异步删除。

     ```mysql
     127.0.0.1:6379&gt; unlink codehole
     (integer) 1
     ```

   * flushdb和flushall，用来清空数据库，这个操作很慢。Redis4.0给这两个指令带来了异步化。

     ```mysql
     127.0.0.1:6379&gt; flushall async # 扔给后台线程删除
     OK
     ```

   * 异步队列

     主线程将对象的引用删除后，会将这个key的内存回收操作包装成一个任务，塞进异步任务队列，后台线程从这个队列取任务。异步队列必须是线程安全的队列。不是所有unlink操作都会延后处理，如果key很小，Redis将会立即回收，跟del指令一样。

     MainThread--submitTask--&gt;ConcurrentQueue--fetchTask--&gt;LazyFreeThread。

   * AOF Sync慢

     Redis需要每秒1次（可自己设置）同步AOF日志到磁盘，确保消息不丢失，需要调用sync函数（这个操作耗时），所以Redis也将这个操作移到异步线程完成。这个线程是一个独立的线程和懒惰删除线程不是同一个，它有自己的任务队列，队列里只存放AOF sync任务。

   * 更多异步删除点，Redis4.0

     * key过期方面，lazyfree-lazy-expire-key：过期删除
     * LRU淘汰，lazyfree-lazy-eviction：内存达到maxmemory时进行淘汰
     * rename指令，lazyfree-lazy-server-del rename：指令删除destKey
     * flush（从节点全量同步时，接收完整的rdb文件后），slave-lazy-flush。

7. **优雅地使用Jedis** | 妙手仁心

   ```java
   import redis.clients.jedis.Jedis;
   import redis.clients.jedis.JedisPool;
   import redis.clients.jedis.exceptions.JedisConnectionException;

   public class JedisTest {
       public static void main(String[] args) {

       }

       private void init1() {
           JedisPool pool = new JedisPool();
           Jedis jedis = pool.getResource(); // 拿出Jedis链接对象
           doSomething(jedis); // 如果这里抛出异常，close将无法执行，如果次数过多，导致新的请求阻塞等待空闲的链接。
           jedis.close(); // 归还链接
       }

       /**
        * 优化1：try-with-resource
        */
       private void init2() {
           JedisPool pool = new JedisPool();
           // try-with-resource 是一种声明了一种或多种资源的try语句，声明了的资源在语句结束的时候都会被关闭
           try (Jedis jedis = pool.getResource()) { //用完自动close
               doSomething(jedis);
           }
       }

       /**
        * 优化2：如果忘了使用try-with-resource?，需要给代码加上硬约束
        */
       interface CallWithJedis {
           public void call(Jedis jedis);
       }

       class RedisPool {
           private JedisPool pool;

           public RedisPool() {
               this.pool = new JedisPool();
           }

           public void execute(CallWithJedis caller) {
               try (Jedis jedis = pool.getResource()) {
                   caller.call(jedis);
               }
           }
       }

       private void init3() {
           RedisPool redis = new RedisPool();
           redis.execute(new CallWithJedis() {
               @Override
               public void call(Jedis jedis) {
                   doSomething(jedis);
               }
           });
       }

       /**
        * 优化3：如果回调里需要修改闭包外的变量
        */
       class Holder&lt;T&gt; {
           private T value;

           public Holder() {
           }

           public Holder(T value) {
               this.value = value;
           }

           public T getValue() {
               return value;
           }

           public void setValue(T value) {
               this.value = value;
           }
       }

       private void init4() {
           RedisPool redis = new RedisPool();
           Holder&lt;Long&gt; countHolder = new Holder&lt;&gt;();
           long c = 0;
           redis.execute(jedis -&gt; {
               long count = jedis.zcard(&quot;codehole&quot;);
               countHolder.setValue(count);
               //c = count; 不能直接修改c，那咋办？那就把c放到一个持有对象里，对象的引用是不变的，但里面的成员变量是可以变的
           });
           System.out.println(countHolder.getValue());
       }

       /**
        * Jedis没有提供重试，需要手动重试。redis-py提供了
        */
       class Redis {
           private JedisPool pool;

           public Redis() {
               this.pool = new JedisPool();
           }

           public void execute(CallWithJedis caller) {
               Jedis jedis = pool.getResource();
               try {
                   caller.call(jedis);
               } catch (JedisConnectionException e) {
                   caller.call(jedis); // 这里可以重试多次，但也不能无限重试
               } finally {
                   jedis.close();
               }
           }
       }
       private void init5() {

       }

       /**
        * 利用jedis做一些事
        * @param jedis
        */
       private static void doSomething(Jedis jedis) {

       }
   }</code></pre><ol start="8">
<li><p><strong>保护Redis</strong> | 居安思危</p>
<p>使用Redis需注意安全风险和防范措施，避免数据泄露和丢失、避免所在主机权限被黑客窃取，避免人为操作失误。</p>
<ul>
<li><p>指令安全</p>
<p>对于危险指令重新命名，比如keys（导致Redis卡顿），flushdb和flushall等。</p>
<p>Redis在配置文件中提供了rename-command指令用于将某些危险的指令修改成特别的名称。比如在security块增加如下：rename-command keys abckeysabc，这样获取所有keys只能通过后面那个指令，而不是keys。如果想完全封杀某条指令，可以将指令rename成空串。如rename-command flushall “”。</p>
</li>
<li><p>端口安全</p>
<p>Redis默认监听6379端口，如果当前服务器主机有外网地址，Redis的服务就会直接暴露在公网上。</p>
<p>在配置文件指定监听的IP地址bind 10.100.20.13</p>
<p>增加Redis密码访问限制，客户端必须使用auth指令</p>
<p>requirepass yoursecurepasswordhereplease</p>
<p>密码控制会影响主从节点复制，从节点需要在配置文件使用masterauth指令配置相应的密码才可以进行复制。masterauth yoursecurepasswordhereplease</p>
</li>
<li><p>Lua脚本安全</p>
<p>开发者必须禁止Lua脚本由用户输入的内容（UGC）生成，这可能让黑客植入攻击代码获取Redis的root权限。应让Redis以普通用户的身份启动，这样即使存在恶意代码，黑客也无法拿到root权限。</p>
</li>
<li><p>SSL代理</p>
<p>Redis不支持SSL链接，所以客户端和服务器之间的交互的数据不应该直接暴露在公网，如果必须要用在公网，可以考虑使用SSL代理。SSL代理常见的有ssh，Redis官网推荐使用spiped工具。SSL代理也可以用在主从复制上。</p>
</li>
</ul>
</li>
<li><p><strong>Redis安全通信</strong> | 隔墙有耳</p>
<ul>
<li><p>spiped原理</p>
<p>Redis Client –send(raw数据)–&gt; (socket server listen port)spiped process(socket client)–send(encrypted)–网络传输–&gt;(socket server listen port)spiped process(scoket client)–send(raw)–&gt;Redis Server。Redis进程成对出现，相互之间需要使用相同的共享密钥来加密消息。</p>
</li>
<li><p>spiped使用入门</p>
<p><a href="https://blog.csdn.net/shenchaohao12321/article/details/88147920" target="_blank" rel="noopener">https://blog.csdn.net/shenchaohao12321/article/details/88147920</a></p>
</li>
</ul>
</li>
</ol>
<h2 id="五、源码篇"><a href="#五、源码篇" class="headerlink" title="五、源码篇"></a>五、源码篇</h2><ol>
<li><p><strong>探索“字符串”内部</strong> | 丝分缕析</p>
<p>结构:</p>
<pre><code>struct SDS&lt;T&gt; { // 泛型优化内存，不同长度的字符串使用不同的结构体表示
    T capacity; // 数组容量
    T len; // 数组长度 刚创建时，len=capacity（大多数场景不使用append修改字符串）
    byte flags; // 特殊标志位
    byte[] content; // 数组内容
}</code></pre><ul>
<li><p>embstr VS raw</p>
<p>字符串两种存储方式：</p>
<ul>
<li>embstr：len &lt;= 44bytes</li>
<li>raw：len &gt; 44bytes</li>
</ul>
<p>Redis对象头结构：占据16字节存储空间</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> RedisObject <span class="token punctuation">{</span>
    int4 type<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 4bits 类型</span>
    int4 encoding<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 4bits 存储形式</span>
    int24 lru<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 24bits 对象的热度 </span>
    int32 refcount<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 32bits 引用计数，为0时，对象会被销毁，内存会被回收</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8bytes, 64-bit system 指向对象内容（body）的具体存储位置</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>SDS结构体大小，在字符串比较小时，SDS结构大小是capacity+3，至少是3字节，T为byte类型，意味着一个字符串最小空间占用为3+16=19字节。</p>
<p>embstr存储形式：它将RedisObject对象头结构和SDS对象连续在一起，使用malloc方法一次分配，而raw需要使用两次malloc方法，两个对象头在内存地址上一般是不连续的。</p>
<p>内存分配器jemalloc、tcmalloc等分配内存大小单位都是2/4/8/16/32/64字节等，为了能容纳embstr对象，jemalloc至少会分配32（32 &gt; 19）字节的空间，如果字符串再长一些，那就是64字节空间。如果字符串总体超过了64字节，Redis就认为它是一个大字符串，应使用raw形式存储。</p>
<p>也就是说embstr最大占64字节，减去对象头19字节以及NULL（字符以NULL结尾，NULL占用一个字节）还剩44字节可存储内容。</p>
</li>
<li><p>扩容策略，老早有讲过：&lt;1MB，加倍，否则+1MB，最大512MB。</p>
</li>
</ul>
</li>
<li><p><strong>探索“字典”内部</strong> | 循序渐进</p>
<p>会用到字典的结构：hash、整个Redis数据库key和value是一个全局字典、带过期时间的key集合、zset存储value和score映射关系。</p>
<pre><code>struct RedisDb {
    dict* dict; //all keys key=&gt;value
    dict* expires; // all expired keys key=&gt;long(timestamp)
    ...
}
struct zset {
    dict *dict; // all values value =&gt; score
    zskiplist *zsl;
}</code></pre><ul>
<li><p>字典内部结构</p>
<pre><code>struct dict {
    ...
    // 字典扩容时，需要分配新的hashtable，然后渐进式搬迁，此时两个hashtable一个是旧的，一个是新的，待搬迁完成后，旧的被删除，新的取而代之。
    dictht ht[2]; // 字典结构包含两个hashtable，通常只有个一个hashtable是有值的。
}</code></pre><p>hashtable结构类似Java的HashMap，数组+链表结构。</p>
<pre><code>struct dictEntry { // 链表节点
    void* key;
    void* val;
    dictEntry* next; // 链接下一个entry
}
struct dictht {
    dictEntry** table // 二维
    long size; // 第一维数组长度
    long used; //hash表中元素的个数
}</code></pre></li>
<li><p>渐进式rehash</p>
<p>搬迁是在如hset、hdel等指令才触发，同时Redis会在定时任务中对字典进行主动搬迁。</p>
</li>
<li><p>查找过程</p>
<p>插入和删除都依赖于查找。</p>
<pre><code>func get(key) {
# hash_func会将key映射为一个整数，不同的key会被映射成分步比较均匀散乱的整数。尽量保证hashtable平衡，查找性能也就好。
    let index = hash_func(key) % size;
    let entry = table[index];
    while(entry != null) {
        if entry.key == target {
            return entry.value;
        }
        entry = entry.next;
    }
}</code></pre></li>
<li><p>hash函数，Redis字典默认的hash函数是siphash。</p>
</li>
<li><p>hash攻击，如果hash函数存在偏向性，黑客可能利用这种偏向性对服务器进行攻击。存在偏向性的hash函数在特定模式下的输入会导致hash第二维链表长度极为不均匀。</p>
</li>
<li><p>扩容条件</p>
<p>当hash表中元素个数大于第一维数组长度，就开始扩容，数组大小翻倍。如果Redis正在做bgsave，为了减少内存页的过多分离，Redis尽量不去扩容，但是如果hash表已经很满了，元素个数达到数组长度5倍，就会强制扩容。</p>
</li>
<li><p>缩容条件：used &lt; szie * 10 %，不会考虑Redis是否正在做bgsave</p>
<p>当hash表元素逐渐被删除而变得稀疏时，就会进行缩容来减少一维数组空间占用。</p>
</li>
<li><p>set的结构，底层也是字典，不过所有的value都是NULL，其他特性和字典一模一样。</p>
</li>
</ul>
</li>
<li><p><strong>探索“压缩列表”内部</strong> | 挨肩叠背</p>
<p>zset和hash在元素个数较少时，采用压缩列表进行存储。</p>
<p>ziplist结构：</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> ziplist<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 是一块连续的内存空间。支持双向遍历</span>
    int32 zlbytes<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 整个zpilist占用字节数</span>
    int32 zltail_offset<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 最后一个元素距起始位置偏移量，用于快速定位到最后一个元素</span>
    int16 zllength<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 元素个数</span>
    T<span class="token punctuation">[</span><span class="token punctuation">]</span> entries<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 元素内容列表</span>
    int8 zlend<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 标志ziplist结束，值恒为0xFF</span>
<span class="token punctuation">}</span>
<span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>zlbytes<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span>
<span class="token punctuation">[</span>zlbytes<span class="token punctuation">]</span><span class="token punctuation">[</span>zltail_offset<span class="token punctuation">]</span><span class="token punctuation">[</span>zllength<span class="token punctuation">]</span><span class="token punctuation">[</span>entry<span class="token punctuation">]</span><span class="token punctuation">[</span>entry<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">[</span>entry<span class="token punctuation">]</span><span class="token punctuation">[</span>zlend<span class="token punctuation">]</span>
<span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>zltail_offset<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span>
<span class="token keyword">struct</span> entry <span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token operator">&lt;</span>var<span class="token operator">></span> prevlen<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前一个entry的字节长度，注意是字节长度，1个长度是1字节</span>
    <span class="token keyword">int</span><span class="token operator">&lt;</span>var<span class="token operator">></span> encoding<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 元素类型编码</span>
    optional byte<span class="token punctuation">[</span><span class="token punctuation">]</span> content<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 元素内容，这个optional即可选的，因为极小整数不需要这个字段。</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>prevlen字段：表示前一个entry的字节长度，用于快速定位到下一个元素的位置（倒序）。它是一个变长的整数。int8 prevlen（1字节，字符串长度小于254（entry长度）），int40 prevlen（5字节，第一个字节值是254。字符串长度&gt;=254）。</p>
<p>encoding字段：存储了元素内容的编码类型信息，决定元素内容类型。Redis是根据这个字段的前缀位识别具体存储的数据形式。</p>
<pre><code>1. 00xxxxxx，短字符串类型，最大长度位数为63，后面的6个位存储字符串的位数，剩余字节就是字符串的内容。
2. 01xxxxxx xxxxxxxx，中等长度字符串，后面14个位表示字符串长，剩余字节就是字符串的内容。
3. 10000000 aaaaaaaa bbbbbbbb cccccccc dddddddd，特大字符串，需使用额外4个字节表示长度。第一个字节前缀是10，剩余6位没有使用，置为零，后面跟字符串内容。一般没有机会使用。
4. 11000000，表示int16，后跟两个字节表示整数
5. 11010000，表示int32，后跟四个字节表示整数
6. 11100000，表示int64，后跟八个字节表示整数
7. 11110000，表示int24，后跟三个字节表示整数
8. 11111110，表示int8，后跟一个字节表示整数
9. 11111111，即zlend，表示ziplist结束
10. 1111xxxx，表示极小整数，xxxx范围只能是0001-1101，即1-13。因为0000，1110和1111被占了。读取到的value需要将xxxx-1，即0-12是最终的value。该类型就无需content了，因为值已经内联到encoding字段。</code></pre><ul>
<li><p>增加元素</p>
<p>ziplist是紧凑的，没有冗余空间，插入一个元素，要么重新分配内存一次性拷贝，然后增加，要么在原有地址上进行扩展。这取决于内存的分配器算法和当前的ziplist内存大小。不适合存储大型字符串，存储的元素不宜过多。</p>
</li>
<li><p>级联更新</p>
<p>如果某个entry经过了修改操作从253变成了254字节，那么它的下一个entry的prevlen需要更细，从1字节扩展到5个字节，如果后面这个entry本身是253，由于prevlen增大了，导致entry整个超过254，所以后面entry的后一个entry的prevlen需要更新，再后面如果还有这样的，仍需要更新。如果后面更新的entry长度没有超过254，那么prevlen就不需要变成5字节了。</p>
<p>如果ziplist里面的每个entry恰好都存储了253字节的内容，那么第一个entry内容修改会导致后续所有的entry级联更新。是非常耗时的。</p>
<p>删除中间的节点也会导致级联更新。</p>
</li>
<li><p>intset小整数集合</p>
<p>set元素是整数，且元素个数较少时，底层用intset存储集合元素（否则用hashtable结构）。它是紧凑的的数组结构。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> intset<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    int32 encoding<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 决定整数位宽是16位，32位还是64位</span>
    int32 length<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//元素个数</span>
    <span class="token keyword">int</span><span class="token operator">&lt;</span>T<span class="token operator">></span> contents<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 整数数组，可以是16位，32位和64位</span>
<span class="token punctuation">}</span>
  4bytes   4bytes
<span class="token punctuation">[</span>encoding<span class="token punctuation">]</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">[</span>value<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p><strong>探索“快速列表”内部</strong> | 风驰电掣</p>
<p>Redis早起版本<strong>list</strong>是ziplist（元素少时）和普通双向链表linkedlist（元素多时）。后来用quicklist。quicklist是ziplist和linkedlist的混合体，它将linkedlist按段切分，每一段用ziplist让存储紧凑，多个ziplist之间使用双向指针串接起来。</p>
<pre><code>|head------------------quicklist---------------------tail|
quickList node &lt;-&gt; quickList node &lt;-&gt; ...&lt;-&gt; quicklist node
     ziplist          ziplist                    ziplist</code></pre><p>quicklist结构定义：</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> ziplist <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token keyword">struct</span> ziplist_compressed <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 压缩的ziplist</span>
    int32 size<span class="token punctuation">;</span>
    byte<span class="token punctuation">[</span><span class="token punctuation">]</span> compressed_data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">struct</span> quicklistNode <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 快速列表节点</span>
    quicklistNode<span class="token operator">*</span> prev<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指向前项节点</span>
    quicklistNode<span class="token operator">*</span> next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指向后项节点</span>
    ziplist<span class="token operator">*</span> zl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指向ziplist</span>
    int32 size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ziplist的字节总数</span>
    int16 count<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ziplist中元素的数量</span>
    int2 encoding<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 存储形式2bit，原生字节数组还是LZF压缩存储</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token keyword">struct</span> quicklist <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 快速列表结构定义</span>
    quicklistNode<span class="token operator">*</span> head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指向头结点</span>
    quicklistNode<span class="token operator">*</span> tail<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指向尾节点</span>
    <span class="token keyword">long</span> count<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 元素个数</span>
    <span class="token keyword">int</span> nodes<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ziplist节点的个数</span>
    <span class="token keyword">int</span> compressDepth<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// LZF算法压缩深度</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>每个ziplist存多少个元素</p>
<p>quicklist内部默认单个ziplist长度为8KB，超出了这个字节数，就会另起一个ziplist。ziplist长度由配置参数list-max-ziplist-size决定。</p>
</li>
<li><p>压缩深度</p>
<p>quicklist默认压缩深度是0，即不压缩。实际深度由配置参数list-compress-depth决定。压缩深度为n(n&gt;0)，表示首尾第1-n个不压缩，n+1个之后才压缩。最大深度nodes / 2。</p>
</li>
</ul>
</li>
<li><p><strong>探索“跳跃列表”内部</strong> | 凌波微步</p>
<p>zset是一个复合结构，包含hashtable（存储value和score的关系）和skiplist（score排序功能，指定score范围获取value列表的功能）。</p>
<ul>
<li><p>基本结构</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> zslnode <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// kv节点，多个kv节点构成双向链表，且有序，从小到大排列。</span>
    string value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果是header，那么值是NULL</span>
    <span class="token keyword">double</span> score<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果是header，那么值是Double.MIN_VALUE</span>
    zslnode<span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span> forward<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 多层连接指针，共有64层，可容纳2^64个元素</span>
    zslnode<span class="token operator">*</span> backward<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 回溯指针</span>
<span class="token punctuation">}</span>
<span class="token keyword">struct</span> zsl <span class="token punctuation">{</span>
    zslnode<span class="token operator">*</span> header<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// skiplist头指针</span>
    <span class="token keyword">int</span> maxLevel<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 跳跃列表当前的最高层</span>
    map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> zslnode<span class="token operator">*</span><span class="token operator">></span> ht<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//hash结构的所有键值对</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>查找过程</p>
<p>从header最高层开始遍历找到第一个节点（比目标小，但再下一个就要大于目标），然后从这个节点再将一层继续类似查找，直到降到最后一层，找到目标值或者最底层最后一个比目标值小的元素。</p>
<p>搜索路径：查找过程中经过的一系列节点组成的列表。</p>
</li>
<li><p>随机层数</p>
<p>对于新插入的节点，需要调用随机算法给它分配一个合理的层数，直观上，有50%概率分配到level1，25%分到level2，12.5%分到level3，以此类推。Redis中节点晋升率是25%。因此官方跳跃列表更加扁平化，层高相对较低，单层需要遍历的节点数会多一些。</p>
</li>
<li><p>插入过程</p>
<p>查找，将搜索路径找出来，开始创建新节点，随机分配新节点层数，将搜索路径上的节点和新节点通过前向后向指针串起来。如果分配的新节点的高度高于当前跳跃列表的最大高度，需要更新最大高度。</p>
</li>
<li><p>删除过程</p>
<p>类似插入过程，对于删除节点的每个层相关节点重排一下前向和后项指针，更新最高层数。</p>
</li>
<li><p>更新过程</p>
<p>调用zadd时，如果对应的value不存在，那就是插入；如果存在，就需要更新，更新策略就是先删除再插入。</p>
</li>
<li><p>如果score值都一样？</p>
<p>这种情况，zset查找性能退化为O(n)，但zset排序元素不只看score值，如果score值相同还需要比较value值（字符串比较），所以不会导致退化为O(n)。</p>
</li>
<li><p>元素排名如何算的？（zset可以获取元素的排名rank）</p>
<p>Redis在skiplist的forward指针上进行了优化，给每一个forward指针都增加了span属性，表示从前一个节点沿着当前层的forward指针跳到当前这个节点中间会跳过多少个节点。Redis在插入，删除都会更新span值。当我们计算一个元素排名时，只需将搜索路径经过的所有节点的跨度span值进行叠加就可以算出最终rank的值。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> zslforward <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 对zslnode进行包装</span>
    zslnode<span class="token operator">*</span> item<span class="token punctuation">;</span>
    <span class="token keyword">long</span> span<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 跨度</span>
<span class="token punctuation">}</span>
<span class="token keyword">struct</span> zsl <span class="token punctuation">{</span>
    string value<span class="token punctuation">;</span>
    <span class="token keyword">double</span> score<span class="token punctuation">;</span>
    zslforward<span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span> forwards<span class="token punctuation">;</span>
    zslnode<span class="token operator">*</span> backward<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p><strong>探索“紧凑列表”内部</strong> | 破旧立新，Redis5.0引入listpack，对ziplist结构的改进版，更节省空间，结构更简单。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> listpack<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    int32 total_bytes<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 占用的总字节数</span>
    int16 size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 元素个数</span>
    T<span class="token punctuation">[</span><span class="token punctuation">]</span> entries<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 紧凑排列的元素列表</span>
    int8 end<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 标志结尾，值恒为oxFF</span>
<span class="token punctuation">}</span>
<span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>total_bytes<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">|</span>
<span class="token punctuation">[</span>total_bytes<span class="token punctuation">]</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">[</span>entry<span class="token punctuation">]</span><span class="token punctuation">[</span>entry<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">[</span>entry<span class="token punctuation">]</span><span class="token punctuation">[</span>end<span class="token punctuation">]</span>
                             <span class="token operator">|</span>
                <span class="token punctuation">[</span>encoding<span class="token punctuation">]</span><span class="token punctuation">[</span>content<span class="token punctuation">]</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span>
<span class="token comment" spellcheck="true">// listpack元素entry结构</span>
<span class="token keyword">struct</span> lpentry <span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token operator">&lt;</span>var<span class="token operator">></span> encoding<span class="token punctuation">;</span>
    optional byte<span class="token punctuation">[</span><span class="token punctuation">]</span> content<span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">&lt;</span>var<span class="token operator">></span> length<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当前元素的长度，最后一个元素位置可以通过total_bytes和最后一个元素长度计算出来。省去了标记最后一个元素位置的zltail_offset。</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>lpentry的length字段使用varint编码，可以是1-5个字节中的任一长度。它通过字节的最高位是否为1决定编码的长度。</p>
<p>encoding字段：</p>
<pre><code>1. 0xxxxxxx，表示整数0-127（0 ~ 2^7-1）
2. 10xxxxxx，表示小字符串，长度范围是0-63（0~2^6-1），content字段为字符串的内容
3. 110xxxxx yyyyyyyy，表示有符号整数-2048~2047（-2^11~2^11-1）疑惑？
4. 1110xxxx yyyyyyyy，表中等长度的字符串，长度范围是0~4095（0-2^12-1），content为内容。
5. 11110000 aaaaaaaa bbbbbbbb cccccccc dddddddd表示大字符串，四个字节表示长度，content为内容
6. 11110001 aaaaaaaa bbbbbbbb 表示2字节有符号整数
7. 11110010 aaaaaaaa bbbbbbbb cccccccc 表示3字节有符号整数
8. 11110011 aaaaaaaa bbbbbbbb cccccccc dddddddd 表示4字节有符号整数
9. 11110011 aaaaaaaa ... hhhhhhhh 表示8字节有符号整数
10.11111111 表示listpack结束符号，即0xFF。</code></pre><ul>
<li><p>级联更新</p>
<p>listpack消除了ziplist存在的级联更新行为。因为他没有前向信息。</p>
</li>
<li><p>取代ziplist（这是listpack的设计目的）</p>
<p>实际上，只有Stream数据结构中使用了listpack，并未取代ziplist，需要考虑兼容性。</p>
</li>
</ul>
</li>
<li><p><strong>探索”基数树“内部</strong> | 金枝玉叶</p>
<p>rax是一个有序字典树（基数树Radix Tree），按照key的字典序排列，支持快速定位、插入和删除操作。zset是根据score排序的。</p>
<p>hash按score排序就是zset，按key排序就是rax。</p>
<ul>
<li><p>应用</p>
<p>英语字典。每个单词(key)按照字典序进行排列，词汇附带解释(value)。可快速检索单词以及查询以某个前缀开头的单词有哪些。</p>
<p>居民档案信息。key是身份证号，value是对应人的信息。</p>
<p>时间序列应用。key为时间戳，value为对应时间点的事件内容。</p>
<p>Web服务器的Router。key是URL规则，value是对应的请求处理器。</p>
<p>Redis Stream结构里面用于存储消息队列。消息ID的前缀是时间戳+序号，使用raw结构存储可快速根据消息ID定位到具体的消息，然后遍历指定消息之后的所有消息。</p>
<p>Redis Cluster中被用来记录槽位和key对应关系。这个对应关系的变量叫slots_to_keys。rax节点的key是由槽位编号hashslot（占2字节，因为数量是16384）和对象key组合而成，同样的hashslot的对象key都会挂在同一个rax节点下面。这样我们可以快速遍历某个槽位下面所有对象的key。</p>
</li>
<li><p>结构，rax节点分为根节点、叶子节点、和中间节点。中间节点可能带value可能不带。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> raxNode <span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span> isKey<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false表示是根节点</span>
    <span class="token keyword">int</span><span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span> isNull<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true表示没有value，是无意义的中间节点</span>
    <span class="token keyword">int</span><span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span> isCompressed<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 是否压缩</span>
    <span class="token keyword">int</span><span class="token operator">&lt;</span><span class="token number">29</span><span class="token operator">></span> size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 叶子节点数量或者是压缩字符串的长度</span>
    byte<span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 路由键、叶子节点指针、value</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>rax不是标准的Radix Tree。如果中间节点有多个叶子节点（表示value），那么路由键（从中间节点到下一个节点增加的一个东西）就是一个字符。如果只有一个叶子节点，那么路由键就是一个字符串（体现了压缩的精神，如果还是一个字符一个字符的下去，直到叶子节点，浪费了空间，反正下面到底就只有一个个节点，那就可以把沿途的路由键压缩成一个字符串了）。</p>
<p>raxNode.data的存储。根据压缩与否分两种：</p>
<ul>
<li><p>压缩结构：叶子节点只有一个，就是压缩结构。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> data <span class="token punctuation">{</span>
    optional <span class="token keyword">struct</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 取决与header（除了data的其他字段组合）的size是否为0</span>
        byte<span class="token punctuation">[</span><span class="token punctuation">]</span> childKey<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 路由键</span>
        raxNode<span class="token operator">*</span> childNode<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 子节点指针</span>
    <span class="token punctuation">}</span> child<span class="token punctuation">;</span>
    optional string value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 取决于header的isNull字段</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//------例子</span>
<span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>raxNode<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token punctuation">(</span>这个节点叶子节点只有一个，因此使用了压缩结构<span class="token punctuation">)</span>
        <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>data<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span>
<span class="token punctuation">[</span>header<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"ship"</span><span class="token punctuation">]</span><span class="token punctuation">[</span>child ptr<span class="token punctuation">]</span><span class="token punctuation">[</span>value ptr<span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token string">"朋友"</span><span class="token punctuation">]</span><span class="token punctuation">(</span>这个<span class="token string">"ship"</span>路由键就是压缩了<span class="token punctuation">)</span>
                  <span class="token operator">|</span><span class="token punctuation">(</span>child ptr指向子节点<span class="token punctuation">)</span>
                  v
               <span class="token punctuation">[</span>header<span class="token punctuation">]</span><span class="token punctuation">[</span>value ptr<span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token string">"友情"</span><span class="token punctuation">]</span>
               <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>raxNode<span class="token operator">--</span><span class="token operator">-</span><span class="token operator">|</span><span class="token punctuation">(</span>这是叶子节点了，没有路由键和child字段<span class="token punctuation">)</span>  、
<span class="token comment" spellcheck="true">// 如果是无意义的中间节点，那么value字段就不存。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>非压缩节点：叶子节点有多个，那就存在多个路由键，一个键就是一个字符，不是压缩结构。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> data <span class="token punctuation">{</span>
    byte<span class="token punctuation">[</span><span class="token punctuation">]</span> childKeys<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 路由键字符列表</span>
    raxNode<span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span> childNodes<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 多个叶子节点指针</span>
    optional string value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 取决于header的isNull字段</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//----------例子</span>
<span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>raxNode<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">|</span>（非压缩节点，es表示两个路由键e和s）
        <span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>data<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span>
<span class="token punctuation">[</span>header<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"es"</span><span class="token punctuation">]</span><span class="token punctuation">[</span>child ptr<span class="token punctuation">]</span><span class="token punctuation">[</span>child ptr<span class="token punctuation">]</span>
                <span class="token operator">|</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>        <span class="token operator">|</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
                <span class="token operator">|</span>        <span class="token punctuation">[</span>header<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"aster"</span><span class="token punctuation">]</span><span class="token punctuation">[</span>child ptr<span class="token punctuation">]</span>（压缩节点）
                <span class="token operator">|</span>                            <span class="token operator">|</span>
                <span class="token operator">|</span>                        <span class="token punctuation">[</span>header<span class="token punctuation">]</span><span class="token punctuation">[</span>value ptr<span class="token punctuation">]</span><span class="token operator">-></span><span class="token punctuation">[</span><span class="token string">"灾难"</span><span class="token punctuation">]</span>（叶子节点）
                v
          <span class="token punctuation">[</span>header<span class="token punctuation">]</span><span class="token punctuation">[</span>value ptr<span class="token punctuation">]</span><span class="token operator">-></span><span class="token punctuation">[</span><span class="token string">"死亡"</span><span class="token punctuation">]</span>（叶子节点）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>有一个节点，当它的叶子节点只有一个，且它的路由键字符串长度为1，压缩不压缩结构形式是一样。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>FLU VS LRU</strong> | 精益求精</p>
<p>LRU，淘汰冷数据（很久未使用的）。FLU(Least Frequently Used)，淘汰很少使用的。</p>
<ul>
<li><p>LRU模式：源码篇字符串部分，讲到Redis头结构有个lru字段。值为Redis时钟server.lrulock。它是一个24bit的整数，默认是Unix时间戳对2^24取模的结果，大约97天清零一次。通过计算对象的空闲时间，即没有被访问的时间，决定淘汰谁。</p>
</li>
<li><p>LFU模式：lru字段用来存储两个值，分别是ldt(last decrement time，占16bit)和logc(logistic counter，占8bit，存储访问频率，实际是频次的对数值)。</p>
<p>logc会随时间衰减，如果它的值比较小，会被回收。新对象默认初始化为LFU_INIT_VAL=5。衰减算法：将现有的logc减去对象的空闲时间（分钟数）再除以一个衰减系数lfu_decay_time(default 1)。如果lfu_decay_time &gt; 1，那么衰减的慢，等于0，表示不衰减。这个值可以调整。logc的更新和LRU模式的lru字段一样，都会在key每次被访问时更新。更新采用概率法进行递增。</p>
<p>ldt用来存储上一次logc的更新时间，值是分钟时间戳对2^16取模，大约每隔45天就会折返。ldt不是在对象被访问时更新的（不像LRU模式的lru），而是在Redis淘汰逻辑（内存达到maxmemory）进行时更新的。淘汰采用随机策略，挑选若干key，更新key的热度，淘汰热度最低的key。</p>
</li>
<li><p>为什么Redis需要缓存系统时间戳</p>
<p>java中通过System.currentTimeMills或者Python的time.time()获取系统的毫秒时间戳，Redis没有这样做，因为每一次获取都是一次系统调用，这比较耗时间。因此Redis需要缓存时间，获取事件都是从缓存中直接拿。（默认Redis时钟值每毫秒更新一次，在定时任务serverCron里主动设置。Redis的很多定时任务都是在serverCron里设置的，如大型hash表的渐进式迁移，过期key的主动淘汰，触发bgsave、bgaofrewrite等。</p>
</li>
<li><p>Redis为什么在获取lrulock时使用原子操作</p>
<p>lruclock使用原子操作atomicGet来获取。由于Redis实际上不是单线程，它背后有多个异步线程在运行，这几个线程也要访问Redis时钟，所以lruclock需要支持多线程读写的。使用atomic能保证多线程lruclock数据的一致性。</p>
</li>
<li><p>如何打开LFU模式</p>
<p>Redis4.0给淘汰策略配置参数maxmemory-policy增加了2个选项，分别是volatile-lfu（对带过期的key执行LFU淘汰算法）和allkeys-lfu（对所有key执行LFU淘汰算法）。</p>
<pre class="line-numbers language-mysql"><code class="language-mysql">> config set maxmemory-policy allkeys-lfu
OK
> set codehole abc
OK
// 获取计数值 初始化为LFU_INIT_VAL=5
> object freq codehole
(integer) 5
// 访问一次
> get codehole
"abc"
> object freq codehole // 计数值增加了
(integer) 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p><strong>懒惰删除的巨大牺牲</strong> | 如履薄冰</p>
<p>异步线程在Redis内部称为BIO（Background IO）。</p>
<ul>
<li><p>懒惰删除最初实现不是异步线程</p>
<p>一开始是类似于字典渐进式搬迁的方式实现渐进式删除回收。</p>
</li>
<li><p>异步线程方案也相当复杂</p>
<p>由于Redis的内部对象有共享机制，作者需要摒弃所有的共享机制，实际上也这样做了。</p>
</li>
<li><p>异步删除的实现</p>
<p>主线程将删除任务传递给异步线程，是通过一个普通的双向链表来传递的，因此处理时需要加锁。</p>
</li>
</ul>
</li>
<li><p><strong>深入字典遍历</strong> | 跋山涉水</p>
<ul>
<li><p>一边遍历一边删除</p>
</li>
<li><p>重复遍历的难题</p>
<p>如果字典正在渐进式迁移，遍历需要对两个遍历。如果遍历过程中进行了rehashStep，遍历会不会出现元素的重复？</p>
</li>
<li><p>迭代器的结构</p>
<p>两种：安全迭代器和不安全迭代器</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dictIterator <span class="token punctuation">{</span>
    dict <span class="token operator">*</span>d<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 目前字典对象</span>
    <span class="token keyword">long</span> index<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 目前遍历的槽位置，初始化为-1</span>
    <span class="token keyword">int</span> table<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ht[0]或ht[1]</span>
    <span class="token keyword">int</span> safe<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//表示迭代器是否安全</span>
    dictEntry <span class="token operator">*</span>entry<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 迭代器当前指向的对象</span>
    dictEntry <span class="token operator">*</span>nextEntry<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 迭代器下一个指向的对象</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>安全迭代器：遍历是可以对字典进行查找和修改。查找和修改会触发过期判断，会删除内部元素。另外，迭代过程也能保证不重复，因为禁止rehashStep。安全迭代器遍历开始时会给字典打个标记，rehashStep见到这个标记就不会执行，遍历是元素就不会重复。</p>
<p>不安全迭代器：遍历过程中，字典是只读不可修改的，不得调用任何可能触发过期判断的函数。好处就是可以rehash，坏处就是遍历元素可能会出现重复。</p>
</li>
<li><p>迭代过程：</p>
</li>
<li><p>迭代器的选择</p>
<p>keys指令使用了安全迭代器。</p>
<p>如果遍历过程不允许出现重复，就使用安全迭代器，如bgaofrewrite，bgsave。</p>
<p>如果遍历过程需要处理元素过期，需要对字典进行修改，需要使用安全迭代器。</p>
<p>其他情况，允许遍历出现个别元素重复，不需要对字典进行结构性修改的情况，一律使用非安全迭代器。</p>
</li>
</ul>
</li>
</ol>
<h2 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h2><ol>
<li><p>Redis慢查询</p>
<p>慢查询日志帮助开发和运维人员定位系统存在的慢操作。慢查询日志就是系统在命令执行前后计算每条命令的执行时间，当超过预设阀值，就将这条命令的相关信息（慢查询ID，发生时间戳，耗时，命令的详细信息）记录下来。Redis客户端命令分为四个部分：发送命令-排队-执行命令-返回结果。慢查询只统计执行命令时间。</p>
</li>
<li><p>Redis 面试全攻略、面试题大集合<a href="https://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&amp;mid=2247488787&amp;idx=2&amp;sn=1528b9f1e82110f5b0a974739397c718&amp;scene=19#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&amp;mid=2247488787&amp;idx=2&amp;sn=1528b9f1e82110f5b0a974739397c718&amp;scene=19#wechat_redirect</a></p>
</li>
<li><p>Docker</p>
<p>Docker 是一个开源的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html" target="_blank" rel="noopener">Go 语言</a> 并遵从 Apache2.0 协议开源。</p>
<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<p>优点：</p>
<ul>
<li><p>快速，一致地交付应用程序</p>
<p>Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。</p>
<p>容器非常适合持续集成和持续交付（CI / CD）工作流程，请考虑以下示例方案：</p>
<ul>
<li>您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。</li>
<li>他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。</li>
<li>当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。</li>
<li>测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。</li>
</ul>
</li>
<li><p>响应部署和扩展</p>
<p>Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。</p>
<p>Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。</p>
</li>
<li><p>在同一硬件上运行更多工作负载</p>
<p>Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。</p>
</li>
</ul>
<p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。image文件是二进制文件。</p>
</li>
<li><p>软件开发模式：瀑布模型-&gt;敏捷开发-&gt;DevOps。</p>
<p>DevOps 集文化理念、实践和工具于一身，可以提高组织高速交付应用程序和服务的能力，与使用传统软件开发和基础设施管理流程相比，能够帮助组织更快地发展和改进产品。这种速度使组织能够更好地服务其客户，并在市场上更高效地参与竞争。</p>
</li>
<li><p>CI/CD，即持续集成，持续交付。</p>
<p>随着 DevOps 的兴起，出现了持续集成，持续交付（CI/CD）和持续部署的新方法。</p>
<p><strong>持续集成</strong>注重将各个开发者的工作集合到一个代码仓库中，通常每天会进行几次，</p>
<p>主要目的是尽早发现集成错误，使团队更加紧密结合，更好地协作。</p>
<p><strong>持续交付</strong>的目的是最小化部署或发布过程中团队固有的摩擦，</p>
<p>它的实现通常能够将构建部署的每个步骤自动化，以便任何时刻能够安全地完成代码发布（理想情况下）。</p>
<p><strong>持续部署</strong>是一种更高程度的自动化，无论何时代码有较大改动，</p>
<p>都会自动进行构建／部署。</p>
</li>
<li><p><strong>UV（Unique visitor）</strong>，一天内同个访客多次访问仅计算一个UV。</p>
<p>是指通过互联网访问、浏览这个网页的自然人。访问您网站的一台电脑客户端为一个访客。00:00-24:00内相同的客户端只被计算一次。</p>
<p><strong>IP（Internet Protocol）</strong></p>
<p>独立IP是指访问过某站点的IP总数，以用户的IP地址作为统计依据。00:00-24:00内相同IP地址之被计算一次。</p>
<p>与UV区别：两个账户在同一电脑登陆，UV = 2，IP = 1</p>
<p><strong>PV（Page View）</strong></p>
<p>即页面浏览量或点击量，用户每1次对网站中的每个网页访问均被记录1个PV。用户对同一页面的多次访问，访问量累计，用以衡量网站用户访问的网页数量。</p>
<p><strong>VV（Visit View）</strong></p>
<p>用以统计所有访客1天内访问网站的次数。当访客完成所有浏览并最终关掉该网站的所有页面时便完成了一次访问，同一访客1天内可能有多次访问行为，访问次数累计。</p>
</li>
<li><p>命令</p>
<ul>
<li><p>redis命令：</p>
<p>【关闭Redis服务】</p>
<p>关闭redis后台服务。由于每次启动机器，redis会自动开启，当使用docker运行redis时，就会与本地reids冲突，因此需要关闭redis服务。(或者卸载本地redis，或者docker中redsi端口映射不和本地redis端口一致)</p>
<p>sudo /etc/init.d/redis-server stop：软件仓库安装的Redis采用init.d脚本关闭</p>
<p>redis-cli shutdown：推荐的方式</p>
<p>Ctrl+C：前台模式启动</p>
<p>Kill + PID：后台模式启动，sudo kill -9 pid，-9表示强制终止</p>
<p>【启动Redis服务】</p>
<p>使用默认配置启动：bin/redis-server，或者直接redis-server启动</p>
<p>指定配置文件启动：bin/redis-server conf/redis.conf</p>
<p>从软件仓库中安装的Redis使用init.d脚本启动：/etc/init.d/redis-server start</p>
<p>以守护进程方式在后台启动：修改reids.conf，将daemonize参数设置为yes，并使用此配置文件启动</p>
<ul>
<li><p>查看redis版本</p>
<p>启动redis-server服务端或redis-cli客户端，输入info</p>
<p>linux下查看服务端版本：redis-server –version 或 redis-server -v</p>
<p>linux下查看客户端版本：redis-cli –version 或 redis-cli -v</p>
</li>
<li><p>查看redis安装的module：module list</p>
</li>
<li><p>删除所有数据库的所有key：flushall</p>
</li>
<li><p>删除当前数据库的所有key：flushdb</p>
</li>
<li><p>切换数据库：select num（redis默认由16个库(0~15号). 且默认使用的是0号库.）</p>
</li>
<li><p>object encoding key，显示五大数据类型的底层数据结构。</p>
</li>
<li><p>debug object key，显示对象信息</p>
</li>
</ul>
</li>
<li><p>docker命令报错:Got permission denied….，docker进程使用Unix socket，而不是tcp端口，默认情况，unix socket属于root用户，因此需要root权限才能访问。</p>
<p>解决办法：</p>
<p>sudo groupadd docker          #添加docker用户组<br>sudo gpasswd -a $XXX docker   #检测当前用户是否已经在docker用户组中，其中XXX为用户名，例如我的，liangll<br>sudo gpasswd -a $USER docker  #将当前用户添加至docker用户组<br>newgrp docker                 #更新docker用户组</p>
</li>
<li><p>linux命令</p>
<ul>
<li><p>ps，process status显示进程状态信息</p>
<p>参数：</p>
<p>-A 列出所有的进程</p>
<p>-aux 显示所有包含其他使用者的进程</p>
<p>例子：ps -aux |grep redis 查看redis相关进程</p>
</li>
<li><p>apt与apt-get</p>
<p>apt = apt-get、apt-cache 和 apt-config 中<strong>最常用命令选项</strong>的集合。也就是说，apt-get中一些细则apt可能无法提供。</p>
<table>
<thead>
<tr>
<th align="center">apt 命令</th>
<th align="center">取代的命令</th>
<th align="center">命令的功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">apt install</td>
<td align="center">apt-get install</td>
<td align="center">安装软件包</td>
</tr>
<tr>
<td align="center">apt remove</td>
<td align="center">apt-get remove</td>
<td align="center">移除软件包</td>
</tr>
<tr>
<td align="center">apt purge</td>
<td align="center">apt-get purge</td>
<td align="center">移除软件包及配置文件</td>
</tr>
<tr>
<td align="center">apt update</td>
<td align="center">apt-get update</td>
<td align="center">刷新存储库索引</td>
</tr>
<tr>
<td align="center">apt upgrade</td>
<td align="center">apt-get upgrade</td>
<td align="center">升级所有可升级的软件包</td>
</tr>
<tr>
<td align="center">apt autoremove</td>
<td align="center">apt-get autoremove</td>
<td align="center">自动删除不需要的包</td>
</tr>
<tr>
<td align="center">apt full-upgrade</td>
<td align="center">apt-get dist-upgrade</td>
<td align="center">在升级软件包时自动处理依赖关系</td>
</tr>
<tr>
<td align="center">apt search</td>
<td align="center">apt-cache search</td>
<td align="center">搜索应用程序</td>
</tr>
<tr>
<td align="center">apt show</td>
<td align="center">apt-cache show</td>
<td align="center">显示装细节</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">新的apt命令</th>
<th align="center">命令的功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">apt list</td>
<td align="center">列出包含条件的包（已安装，可升级等）</td>
</tr>
<tr>
<td align="center">apt edit-sources</td>
<td align="center">编辑源列表</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>docker命令</p>
<p>apt-get install docker.io #安装docker</p>
<p>apt-get remove docker docker-engine docker.io # 卸载docker</p>
<p>docker version 或 docker info # 验证安装是否成功</p>
<p>docker pull redislabs/rebloom # 拉取镜像 ，这里是redis的布隆过滤器</p>
<p>docker run -p6379:6379 redislabs/rebloom # 运行容器</p>
<p>redis-cli # 在另一命令行窗口打开redis服务</p>
</li>
<li><p>vim，三种模式</p>
<p>命令模式：用户刚启动，就进入命令模式</p>
<ul>
<li>i 切换到输入模式</li>
<li>x 删除当前光标所在处的字符</li>
<li>: 切换到底线命令模式，在最底一行输入命令</li>
</ul>
<p>输入模式：可以输入任何字符，esc退回到一般模式</p>
<p>底线命令模式：在命令模式按下:就进入了底线命令模式</p>
<ul>
<li>q 退出程序</li>
<li>w保存文件</li>
</ul>
<p>一般情况，我们用vim打开某文件，然后按i、o或a进入输入模式，然后按esc进入一般模式，然后输入:wq即可保存退出了。不保存退出:q即可。</p>
</li>
</ul>
</li>
<li><p>语言</p>
<ul>
<li><p>Python</p>
<p>下划线：</p>
<ul>
<li>单前导下划线：_var：以单个下划线开头的变量或方法仅供内部使用，这是约定，不是强制</li>
<li>单末尾下划线：var_：避免与Python关键字产生命名冲突，如class_</li>
<li>双前导下划线：__val：双下划线前缀会导致Python解释器重写属性名称，以避免子类中的命名冲突。这也叫做名称修饰（name mangling） - 解释器更改变量的名称，以便在类被扩展的时候不容易产生冲突。</li>
<li>双前导和末尾下划线：__val__：特殊用途，如__init__对象构造函数，或__call__ — 它使得一个对象可以被调用。</li>
<li>单下划线：_：单个独立下划线是用作一个名字，来表示某个变量是临时的或无关紧要的</li>
</ul>
<p>format格式化函数</p>
<p>python2.6增加了{}和:代替以前的%</p>
<p>“ab{} {}”.format(“a”, “b”)，结果就是abab</p>
<p>“ab{1}{0}”.format(“a”, “b”)，指定位置，结果就是abba</p>
</li>
</ul>
</li>
</ol>

            </div>
            <hr />

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">写作不易，客官能否打赏一杯奶茶？</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《Redis深度历险 | 学习记录》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2021/04/21/redis-shen-du-li-xian-xue-xi-ji-lu/" property="cc:attributionName"
               rel="cc:attributionURL">
                猷煜
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
    <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '9ce7367c220159d88a03',
        clientSecret: 'fca0c7bb865991c5e344c97afffcc05d31173893',
        repo: 'renwu2019.github.io',
        owner: 'renwu2019',
        admin: "renwu2019",
        id: '2021/04/21/redis-shen-du-li-xian-xue-xi-ji-lu/',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-dot-circle-o"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2021/04/21/redis-shen-du-li-xian-xue-xi-ji-lu/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/14.jpg" class="responsive-img" alt="Redis深度历险 | 学习记录">
                        
                        <span class="card-title">Redis深度历险 | 学习记录</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Redis深度历险-核心原理与应用实践（钱文品）redis经典问题：数据缓存，使用get/set方法。Redis分布式锁及其内部实现机制，Redis是单线程结构，支持高并发。
一、基础应用篇
Redis（Remote Dictionary 
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2021-04-21
                            </span>
                        <span class="publish-author">
                            
                        </span>
                    </div>
                </div>

                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/03/24/java8/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="java8新特性 | 学习记录">
                        
                        <span class="card-title">java8新特性 | 学习记录</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            一、java8发展1. jdk5
自动装箱与拆箱
并发库
枚举，常用于代表某些状态值，标识符，或者一些特定的类型。
静态导入， import static
变长参数，三个点，要求参数类型相同，且是参数列表的最后一项。
泛型，本质：参数化类型
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2021-03-24
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/编程语言/" class="post-category" target="_blank">
                                    编程语言
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/java8/" target="_blank">
                        <span class="chip bg-color">java8</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 猷煜的博客<br />'
            + '作者: 猷煜<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>

<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
<script>
    const btw = new BTWPlugin();
    btw.init({
        id: '',
        blogId: '',
        name: '',
        qrcode: 'https://123.jpg',
        keyword: 'VIP',
    });
</script>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2021-2022 YouYu. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">51.1k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
            <br>
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                <i class="fa fa-heart-o"></i>
                本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <span id="busuanzi_container_site_uv" style='display:none'>
                人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
            </span>
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/renwu2019" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:1327756702@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>


<!---->


    <a href="http://wpa.qq.com/msgrd?v=3&uin=1327756702&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的qq" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>


<!---->


    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        //var pvcountOffset = 80000;
        var pvcountOffset = 0;
        //var uvcountOffset = 20000;
        var uvcountOffset = 0;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2021, 03, 24, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=查教程获取"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '查教程获取');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    <!-- 雪花特效 -->
    

</body>

</html>